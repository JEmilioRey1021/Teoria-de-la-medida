<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>隆Que Coman Pasteles! - El Juego de la Revoluci贸n Francesa</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Crete+Round&display=swap'); /* For a more historical/gamey feel */

        body {
            font-family: 'Inter', sans-serif;
            background-color: #2c3e50; /* Dark blue-grey, reminiscent of historical times */
            color: #ecf0f1; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            flex-direction: column;
            padding: 1rem;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            padding: 1.5rem;
            background-color: #34495e; /* Slightly lighter dark background for container */
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4), 0 6px 6px rgba(0, 0, 0, 0.2);
            max-width: 95vw;
            width: 100%;
            box-sizing: border-box;
        }

        @media (min-width: 768px) {
            .game-wrapper {
                flex-direction: row;
                justify-content: center;
                align-items: flex-start;
                max-width: 1000px; /* Max width for larger screens */
            }
        }

        h1 {
            font-family: 'Crete Round', serif;
            font-size: 2.5rem;
            color: #f1c40f; /* Gold-like color */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 1rem;
            text-align: center;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        canvas {
            background-color: #000; /* Game board background */
            border: 4px solid #95a5a6; /* Silver border */
            border-radius: 0.5rem;
            display: block;
            touch-action: none; /* Disable default touch actions like scrolling */
            width: 100%; /* Make canvas fluid */
            max-width: 600px; /* Max width for game canvas */
            height: 400px; /* Fixed height for game canvas */
            box-sizing: border-box;
        }

        @media (min-width: 768px) {
            canvas {
                height: 600px; /* Taller on larger screens */
            }
        }

        .game-info {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 150px;
            padding: 1rem;
            background-color: #2c3e50;
            border-radius: 0.5rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .info-panel {
            background-color: #34495e;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            font-weight: bold;
            font-size: 1.125rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .score-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .score-icon {
            width: 24px;
            height: 24px;
            vertical-align: middle;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .control-button {
            background-color: #e74c3c; /* Red button for action */
            color: #fff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        .control-button:hover {
            background-color: #c0392b;
            transform: translateY(-2px);
        }

        .control-button:active {
            background-color: #a52a22;
            transform: translateY(0);
            box-shadow: none;
        }

        .control-button.move {
            background-color: #3498db; /* Blue for movement */
        }
        .control-button.move:hover {
            background-color: #2980b9;
        }
        .control-button.move:active {
            background-color: #21618c;
        }

        /* Modal for questions */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-content {
            background-color: #34495e;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            text-align: center;
            color: #ecf0f1;
            font-family: 'Inter', sans-serif;
        }

        .modal-content h2 {
            font-family: 'Crete Round', serif;
            font-size: 1.8rem;
            margin-bottom: 1rem;
            color: #f1c40f;
        }

        .modal-content p {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
        }

        .modal-options button {
            display: block;
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 0.8rem;
            background-color: #2ecc71; /* Green for options */
            color: #fff;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .modal-options button:hover {
            background-color: #27ae60;
        }
        .modal-options button.incorrect {
            background-color: #e74c3c; /* Red for incorrect */
        }
        .modal-options button.correct {
            background-color: #27ae60; /* Green for correct */
        }

        .modal-feedback {
            margin-top: 1rem;
            font-weight: bold;
            font-size: 1.1rem;
        }
        .modal-feedback.correct {
            color: #2ecc71;
        }
        .modal-feedback.incorrect {
            color: #e74c3c;
        }

        .modal-continue-button {
            background-color: #3498db;
            color: #fff;
            padding: 0.8rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            margin-top: 1.5rem;
            transition: background-color 0.2s ease-in-out;
            border: none;
            outline: none;
        }
        .modal-continue-button:hover {
            background-color: #2980b9;
        }

        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 1.5rem;
            z-index: 1000;
            border-radius: 1rem;
            text-align: center;
        }

        .game-over-text {
            font-family: 'Crete Round', serif;
            font-size: 3rem;
            font-weight: bold;
            color: #e74c3c; /* Red for game over */
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
        }

        .final-score {
            font-size: 1.8rem;
            color: #f1c40f;
            margin-top: 1rem;
            font-weight: bold;
        }

        .restart-button {
            background-color: #2ecc71; /* Green button */
            color: #fff;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 6px 8px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        .restart-button:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }

        .restart-button:active {
            background-color: #218c57;
            transform: translateY(0);
            box-shadow: none;
        }
    </style>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables (will be initialized in initGame)
        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.userId = null;

        // Function to initialize Firebase and authenticate
        window.initFirebase = async () => {
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing. High score will not be saved.");
                    return;
                }

                window.firebaseApp = initializeApp(firebaseConfig);
                window.db = getFirestore(window.firebaseApp);
                window.auth = getAuth(window.firebaseApp);

                // Sign in anonymously or with custom token
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(window.auth, __initial_auth_token);
                } else {
                    await signInAnonymously(window.auth);
                }

                onAuthStateChanged(window.auth, (user) => {
                    if (user) {
                        window.userId = user.uid;
                        console.log("Firebase user ID:", window.userId);
                        // Once authenticated, load high score
                        window.loadHighScore();
                    } else {
                        console.log("No user signed in to Firebase.");
                        window.userId = null;
                    }
                });

            } catch (error) {
                console.error("Error initializing Firebase:", error);
            }
        };

        // Function to load high score from Firestore
        window.loadHighScore = async () => {
            if (!window.db || !window.userId) {
                console.log("Firestore or user ID not ready to load high score.");
                return 0;
            }
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const highScoreDocRef = doc(window.db, `artifacts/${appId}/users/${window.userId}/high_scores/personal_high_score`);
                const docSnap = await getDoc(highScoreDocRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    window.highScore = data.score || 0;
                    console.log("Loaded high score:", window.highScore);
                } else {
                    window.highScore = 0;
                    console.log("No high score found for this user, starting at 0.");
                }
                document.getElementById('highScoreDisplay').textContent = window.highScore;
            } catch (error) {
                console.error("Error loading high score:", error);
                window.highScore = 0; // Fallback
            }
        };

        // Function to save high score to Firestore
        window.saveHighScore = async (newScore) => {
            if (!window.db || !window.userId || newScore <= window.highScore) {
                console.log("Not saving high score. Either Firestore/user ID not ready or new score is not higher.");
                return;
            }
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const highScoreDocRef = doc(window.db, `artifacts/${appId}/users/${window.userId}/high_scores/personal_high_score`);
                await setDoc(highScoreDocRef, { score: newScore, timestamp: new Date() });
                window.highScore = newScore; // Update global high score
                document.getElementById('highScoreDisplay').textContent = window.highScore;
                console.log("High score saved successfully:", newScore);
            } catch (error) {
                console.error("Error saving high score:", error);
            }
        };
    </script>
</head>
<body>
    <h1>隆Que Coman Pasteles!</h1>
    <div class="game-wrapper">
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            <div class="controls">
                <button id="leftBtn" class="control-button move">Izquierda</button>
                <button id="shootBtn" class="control-button">隆Disparar!</button>
                <button id="rightBtn" class="control-button move">Derecha</button>
                <button id="musicToggleBtn" class="control-button move">M煤sica: ON</button> </div>
        </div>
        <div class="game-info">
            <div class="info-panel">
                <div class="score-display">
                    Puntuaci贸n: <span id="score">0</span>
                    <img src="https://placehold.co/24x24/fbd38d/34495e?text=" alt="Pastelito" class="score-icon">
                </div>
            </div>
            <div class="info-panel">
                R茅cord: <span id="highScoreDisplay">0</span>
            </div>
            <div class="info-panel">
                Nivel: <span id="level">1</span>
            </div>
            <div class="info-panel">
                Oleada: <span id="currentWaveDisplay">1</span>/<span id="totalWavesInLevelDisplay">1</span>
            </div>
            <div class="info-panel">
                Enemigos Restantes: <span id="enemiesRemaining">0</span>
            </div>
            <div id="activePowerUpDisplay" class="info-panel">
                Poder Activo: Ninguno
            </div>
        </div>
    </div>

    <div id="gameOverOverlay" class="game-over-overlay" style="display: none;">
        <div class="game-over-text">隆La Monarqu铆a ha Ganado!</div>
        <div class="final-score">Pastelitos Obtenidos: <span id="finalScore">0</span> </div>
        <button id="restartBtn" class="restart-button">Jugar de Nuevo</button>
    </div>

    <div id="questionModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="questionTitle">Pregunta Hist贸rica</h2>
            <p id="questionText"></p>
            <div id="questionOptions" class="modal-options">
                </div>
            <div id="questionFeedback" class="modal-feedback"></div>
            <button id="modalContinueBtn" class="modal-continue-button" style="display: none;">Continuar Juego</button>
        </div>
    </div>

    <audio id="backgroundMusic" loop preload="auto">
        <!-- 
            Nota sobre la reproducci贸n de m煤sica:
            Los navegadores modernos a menudo bloquean la reproducci贸n autom谩tica de medios con sonido
            hasta que el usuario interact煤a con la p谩gina. Si la m煤sica no se reproduce autom谩ticamente
            al iniciar el juego, por favor, haz clic en el bot贸n "M煤sica: ON/OFF" para activarla.
        -->
        <source src="https://drive.google.com/uc?export=download&id=1AieS3xLLPnEvmL1qGt91PP9tdDJFP4vs" type="audio/mpeg">
        Tu navegador no soporta el elemento de audio.
    </audio>

    <script type="module">
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScoreDisplay'); // New high score display
        const levelDisplay = document.getElementById('level');
        const currentWaveDisplay = document.getElementById('currentWaveDisplay'); // New wave display
        const totalWavesInLevelDisplay = document.getElementById('totalWavesInLevelDisplay'); // New total waves display
        const enemiesRemainingDisplay = document.getElementById('enemiesRemaining');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const shootBtn = document.getElementById('shootBtn');
        const activePowerUpDisplay = document.getElementById('activePowerUpDisplay');
        const musicToggleBtn = document.getElementById('musicToggleBtn'); // Music toggle button
        const backgroundMusic = document.getElementById('backgroundMusic'); // Audio element

        const questionModal = document.getElementById('questionModal');
        const questionTitle = document.getElementById('questionTitle');
        const questionText = document.getElementById('questionText');
        const questionOptions = document.getElementById('questionOptions');
        const questionFeedback = document.getElementById('questionFeedback');
        const modalContinueBtn = document.getElementById('modalContinueBtn');

        // Game settings
        const GAME_WIDTH = 600; // Fixed width for game logic
        const GAME_HEIGHT = 400; // Fixed height for game logic (will scale with CSS)
        const GUILLOTINE_WIDTH = 60;
        const GUILLOTINE_HEIGHT = 60;
        const PROJECTILE_WIDTH = 8;
        const PROJECTILE_HEIGHT = 20;
        let ENEMY_BASE_WIDTH = 50; // Base size, can be scaled
        let ENEMY_BASE_HEIGHT = 50; // Base size, can be scaled
        const INITIAL_ENEMY_ROWS = 3;
        const INITIAL_ENEMY_COLS = 5;
        const INITIAL_ENEMY_SPACING_X = 70;
        const INITIAL_ENEMY_SPACING_Y = 60;
        const ENEMY_START_Y = 50; // Fixed initial Y position for enemies

        // Obstacle settings
        const DESTRUCTIBLE_ROCK_HEALTH = 3;
        const DESTRUCTIBLE_ROCK_POINTS = 75;
        const INDESTRUCTIBLE_ROCK_POINTS = 0;

        // Power-up settings
        const POWER_UP_DURATION_TRIPLE = 8000; // 8 seconds
        const POWER_UP_DURATION_RAPID = 8000; // 8 seconds
        const POWER_UP_DURATION_PIERCING = 7000; // 7 seconds
        const POWER_UP_DURATION_FREEZE = 5000; // 5 seconds
        const POWER_UP_DURATION_DRONE = 5000; // 5 seconds

        const POWER_UP_WIDTH = 40;
        const POWER_UP_HEIGHT = 40;

        // Boss settings
        const BOSS_WAVE_INTERVAL = 10; // Boss appears every 10 waves cleared
        const BOSS_HEALTH_MULTIPLIER = 5; // Boss health is 5x a regular enemy (base)
        const BOSS_SIZE_MULTIPLIER = 2.5; // Boss is 2.5x larger than base enemy
        const BOSS_ATTACK_COOLDOWN = 1500; // Boss attacks every 1.5 seconds

        let guillotine;
        let projectiles = [];
        let enemies = [];
        let obstacles = []; // New array for obstacles
        let powerUps = []; // New array for falling power-ups
        let drones = []; // New array for active drones
        let boss = null; // Current boss instance
        let bossProjectiles = []; // Projectiles fired by the boss

        let score = 0;
        let highScore = 0; // Global high score variable
        let level = 1;
        let currentWave = 1; // Current wave within the level
        let totalWavesInLevel = 1; // Total waves for the current level
        let wavesClearedTotal = 0; // Total waves cleared across all levels

        let gameLoopId;
        let isGameOver = false;
        let gamePaused = false;
        let enemiesDefeatedThisLevel = 0;

        let activePowerUp = null;
        let powerUpEndTime = 0;
        let originalShootCooldown = 500;
        let currentProjectileWidth = PROJECTILE_WIDTH;
        let currentProjectileHeight = PROJECTILE_HEIGHT;

        let enemiesAreFrozen = false;
        let freezeEndTime = 0;

        // Level configuration for difficulty scaling (up to 30 levels)
        const MAX_LEVELS = 30;
        const levelConfigs = [];

        for (let i = 1; i <= MAX_LEVELS; i++) {
            levelConfigs.push({
                level: i,
                // Waves increase every 5 levels, max 5 waves
                numWaves: Math.min(5, 1 + Math.floor((i - 1) / 5)),
                // Base enemies per wave, increases with level
                baseEnemiesPerWave: Math.min(25, 5 + Math.floor(i * 0.8)),
                // Base obstacles per wave, increases with level
                baseObstaclesPerWave: Math.min(10, Math.floor(i * 0.3)),
                waveDelay: 2000, // 2 seconds between waves
                // Power-up drop chance increases, but not too high
                powerUpDropChance: Math.min(0.5, 0.05 + (i * 0.02)),
                // Rock spawn chance increases
                rockSpawnChance: Math.min(0.5, 0.05 + (i * 0.02)),
                // Indestructible rock chance increases
                indestructibleRockChance: Math.min(0.8, 0.1 + (i * 0.03)),
                // Enemy speed increases, but starting slower and scaling less aggressively
                enemySpeedMultiplier: 0.2 + (i * 0.05), // Adjusted from 0.5 + (i * 0.15)
                // Guillotine cooldown reduction (faster shooting)
                guillotineCooldownReduction: Math.max(50, 500 - (i * 15)), // Min cooldown 50ms
                // Enemy size reduction for higher levels
                enemySizeMultiplier: i > 10 ? Math.max(0.7, 1 - ((i - 10) * 0.02)) : 1 // Reduce size after level 10
            });
        }


         // Game Images (using placeholders for now)
        const guillotineImage = new Image();
        guillotineImage.src = "guillotina.png"; // Guillotine icon

        const marieAntoinetteImage = new Image();
        marieAntoinetteImage.src = "mariaantonietta.png"; // Marie Antoinette

        const louisXVIImage = new Image();
        louisXVIImage.src = "LuisXVI.png"; // Luis XVI

        const crownImage = new Image();
        crownImage.src = "corona.png"; // Corona

        const triangleImage = new Image(); // New image for triangle enemy
        triangleImage.src = "soldado.png"; // Soldado (triangle enemy)

        const destructibleRockImage = new Image();
        destructibleRockImage.src = "pergamino.png"; // Pergamino (destructible rock)

        const indestructibleRockImage = new Image();
        indestructibleRockImage.src = "bloque.png"; // Bloque (indestructible rock)

        // New image for the boss (giant Marie Antoinette)
        const bossMarieAntoinetteImage = new Image();
        bossMarieAntoinetteImage.src = "buzzAntonietta.png"; // Buzz Antonietta (boss)

        // Power-up images (placeholders)
        const tripleShotImage = new Image();
        tripleShotImage.src = "tripleshot.png"; // Triple Shot

        const rapidFireImage = new Image();
        rapidFireImage.src = "rapidfire.png"; // Rapid Fire

        const piercingBulletImage = new Image();
        piercingBulletImage.src = "piercingbullet.png"; // Piercing Bullet

        const enemyFreezeImage = new Image();
        enemyFreezeImage.src = "congelado.png"; // Enemy Freeze

        const droneCompanionImage = new Image();
        droneCompanionImage.src = "dron.png"; // Drone Companion


        // Power-up types and their properties
        const POWER_UP_TYPES = {
            'triple_shot': {
                image: tripleShotImage,
                effect: 'triple_shot',
                name: 'Disparo Triple',
                duration: POWER_UP_DURATION_TRIPLE
            },
            'rapid_fire': {
                image: rapidFireImage,
                effect: 'rapid_fire',
                name: 'Disparo R谩pido',
                duration: POWER_UP_DURATION_RAPID
            },
            'piercing_bullet': {
                image: piercingBulletImage,
                effect: 'piercing_bullet',
                name: 'Bala Perforante',
                duration: POWER_UP_DURATION_PIERCING
            },
            'enemy_freeze': {
                image: enemyFreezeImage,
                effect: 'enemy_freeze',
                name: 'Congelaci贸n Enemiga',
                duration: POWER_UP_DURATION_FREEZE
            },
            'drone_companion': {
                image: droneCompanionImage,
                effect: 'drone_companion',
                name: 'Acompa帽ante Dron',
                duration: POWER_UP_DURATION_DRONE
            }
        };


        // Game Entities
        class Guillotine {
            constructor() {
                this.width = GUILLOTINE_WIDTH;
                this.height = GUILLOTINE_HEIGHT;
                this.x = (GAME_WIDTH - this.width) / 2;
                this.y = GAME_HEIGHT - this.height - 10;
                this.speed = 5;
                this.currentShootCooldown = originalShootCooldown; // Initial cooldown in milliseconds
                this.lastShotTime = 0; // Timestamp of the last shot
            }

            draw() {
                ctx.drawImage(guillotineImage, this.x, this.y, this.width, this.height);
            }

            moveLeft() {
                this.x = Math.max(0, this.x - this.speed);
            }

            moveRight() {
                this.x = Math.min(GAME_WIDTH - this.width, this.x + this.speed);
            }

            // createProjectile now takes dx for angle and isPiercing flag
            createProjectile(dx = 0, isPiercing = false, isDroneShot = false) {
                projectiles.push(new Projectile(this.x + this.width / 2 - currentProjectileWidth / 2, this.y, dx, isPiercing, isDroneShot));
            }
        }

        class Projectile {
            constructor(x, y, dx = 0, isPiercing = false, isDroneShot = false) { // dx: -1 for left, 0 for straight, 1 for right
                this.x = x;
                this.y = y;
                this.width = isDroneShot ? PROJECTILE_WIDTH * 0.7 : PROJECTILE_WIDTH; // Smaller for drone
                this.height = isDroneShot ? PROJECTILE_HEIGHT * 0.7 : PROJECTILE_HEIGHT; // Smaller for drone
                this.speed = isDroneShot ? 5 : 7; // Slower for drone
                this.dx = dx * (this.speed / 2); // Horizontal speed component for angled shots
                this.isPiercing = isPiercing;
                this.isDroneShot = isDroneShot;
            }

            draw() {
                if (this.isPiercing) {
                    ctx.fillStyle = '#3498db'; // Blue for piercing
                } else if (this.isDroneShot) {
                    ctx.fillStyle = '#f1c40f'; // Yellow for drone shot
                } else {
                    ctx.fillStyle = '#f39c12'; // Orange/Yellow for normal projectile
                }
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            update() {
                this.y -= this.speed;
                this.x += this.dx; // Move horizontally for angled shots
            }
        }

        class Enemy {
            constructor(x, y, type, currentEnemyWidth, currentEnemyHeight, enemySpeedMultiplier, guaranteedPowerUpDrop = false, powerUpTypeToDrop = null) {
                this.x = x;
                this.y = y;
                this.width = currentEnemyWidth;
                this.height = currentEnemyHeight;
                this.type = type;
                this.image = this.getImageByType(type);
                // Base speed with random variation
                this.speedX = (0.5 + enemySpeedMultiplier) * (0.75 + Math.random() * 0.5); // 75% to 125% of base speed
                this.speedY = 0.1; // Constant downward drift
                this.directionX = Math.random() < 0.5 ? 1 : -1; // Initial horizontal direction
                this.points = this.getPointsByType(type);
                this.guaranteedPowerUpDrop = guaranteedPowerUpDrop; // New property for guaranteed power-up drop
                this.powerUpTypeToDrop = powerUpTypeToDrop; // Specific power-up type to drop

                // Timer for random horizontal direction changes
                this.randomDirectionChangeInterval = 1000 + Math.random() * 2000; // Change every 1 to 3 seconds
                this.lastDirectionChangeTime = performance.now();
            }

            getImageByType(type) {
                switch (type) {
                    case 'marie': return marieAntoinetteImage;
                    case 'louis': return louisXVIImage;
                    case 'crown': return crownImage;
                    case 'triangle': return triangleImage; // Use triangle image
                    default: return crownImage; // Fallback
                }
            }

            getPointsByType(type) {
                switch (type) {
                    case 'marie': return 50;
                    case 'louis': return 40;
                    case 'crown': return 20;
                    case 'triangle': return 30; // Points for triangle enemy
                    default: return 10;
                }
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                // Optional: Draw a "frozen" overlay
                if (enemiesAreFrozen) {
                    ctx.fillStyle = 'rgba(173, 216, 230, 0.5)'; // Light blue translucent overlay
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }

            update() {
                if (!enemiesAreFrozen) { // Only move if not frozen
                    const now = performance.now();

                    // Randomly change horizontal direction
                    if (now - this.lastDirectionChangeTime > this.randomDirectionChangeInterval) {
                        this.directionX *= -1; // Flip direction
                        this.randomDirectionChangeInterval = 1000 + Math.random() * 2000; // New random interval
                        this.lastDirectionChangeTime = now;
                    }

                    // Simple side-to-side movement and then drop
                    this.x += this.speedX * this.directionX;
                    this.y += this.speedY; // Constant downward movement

                    // Reverse direction if hitting horizontal boundaries
                    if (this.x + this.width > GAME_WIDTH || this.x < 0) {
                        this.directionX *= -1; // Reverse horizontal direction
                        // REMOVED: this.y += this.height / 2; // This caused rapid drops
                    }

                    // Game over if enemy reaches bottom
                    if (this.y + this.height > GAME_HEIGHT) {
                        endGame();
                    }
                }
            }
        }

        class Obstacle {
            constructor(x, y, type, currentObstacleWidth, currentObstacleHeight, obstacleSpeedMultiplier, guaranteedPowerUpDrop = false, powerUpTypeToDrop = null) {
                this.x = x;
                this.y = y;
                this.width = currentObstacleWidth; // Rocks can be same size as enemies for simplicity
                this.height = currentObstacleHeight;
                this.type = type; // 'destructible_rock' or 'indestructible_rock'
                this.isIndestructible = (type === 'indestructible_rock');
                this.health = this.isIndestructible ? Infinity : DESTRUCTIBLE_ROCK_HEALTH;
                this.initialColor = this.isIndestructible ? '#606060' : '#a0a0a0'; // Darker grey for indestructible, lighter for destructible
                this.color = this.initialColor;
                this.points = this.isIndestructible ? INDESTRUCTIBLE_ROCK_POINTS : DESTRUCTIBLE_ROCK_POINTS;
                this.speed = 0.5 * obstacleSpeedMultiplier; // Rocks move at a slightly slower but increasing speed
                this.direction = 1; // 1 for right, -1 for left
                this.image = this.isIndestructible ? indestructibleRockImage : destructibleRockImage;
                this.guaranteedPowerUpDrop = guaranteedPowerUpDrop; // New property for guaranteed power-up drop
                this.powerUpTypeToDrop = powerUpTypeToDrop; // Specific power-up type to drop
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                // Optional: Draw health indicator for destructible rocks
                if (!this.isIndestructible && this.health > 0) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Inter'; // Use Inter font for consistency
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.health, this.x + this.width / 2, this.y + this.height / 2);
                }
            }

            update() {
                // ONLY destructible rocks move
                if (!this.isIndestructible && !enemiesAreFrozen) { // Destructible rocks also freeze
                    this.x += this.speed * this.direction;

                    if (this.x + this.width > GAME_WIDTH || this.x < 0) {
                        this.direction *= -1;
                        this.y += this.height / 2; // Drop down when hitting wall (use obstacle's height)
                    }

                    // Game over if moving obstacle reaches bottom
                    if (this.y + this.height > GAME_HEIGHT) {
                        endGame(); // Moving rocks reaching bottom also cause game over
                    }
                }
                // Indestructible rocks do not move or trigger game over by falling off screen (as they don't fall)
            }

            takeHit() {
                if (!this.isIndestructible) {
                    this.health--;
                    // Removed the temporary image change on hit, now it will just show the health number
                    // You could add a subtle visual effect here if desired, without changing the image source
                }
            }
        }

        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = POWER_UP_WIDTH;
                this.height = POWER_UP_HEIGHT;
                this.type = type;
                this.image = POWER_UP_TYPES[type].image;
                this.speed = 2; // Power-ups fall slowly
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            }

            update() {
                this.y += this.speed; // Power-ups fall down
            }
        }

        class Drone {
            constructor(guillotine) {
                this.guillotine = guillotine;
                this.width = GUILLOTINE_WIDTH * 0.6; // Smaller than guillotine
                this.height = GUILLOTINE_HEIGHT * 0.6;
                this.x = this.guillotine.x + this.guillotine.width / 2 - this.width / 2; // Follow guillotine
                this.y = this.guillotine.y - this.height - 10; // Slightly above guillotine
                this.speed = 5; // Movement speed to follow guillotine
                this.shootCooldown = 600; // Drone shoots a bit slower than player
                this.lastShotTime = 0;
                this.image = droneCompanionImage; // Use drone image
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            }

            update() {
                // Follow guillotine's X position
                this.x = this.guillotine.x + this.guillotine.width / 2 - this.width / 2;

                // Make drone shoot
                const now = performance.now();
                if (now - this.lastShotTime > this.shootCooldown) {
                    projectiles.push(new Projectile(this.x + this.width / 2 - PROJECTILE_WIDTH / 2, this.y, 0, false, true)); // Drone shot
                    this.lastShotTime = now;
                }
            }
        }

        class Boss {
            constructor() {
                this.width = ENEMY_BASE_WIDTH * BOSS_SIZE_MULTIPLIER; // Giant Marie Antoinette
                this.height = ENEMY_BASE_HEIGHT * BOSS_SIZE_MULTIPLIER;
                this.x = (GAME_WIDTH - this.width) / 2;
                this.y = 20; // Start near the top
                this.image = bossMarieAntoinetteImage; // Use the distinct boss image
                this.health = 10 * BOSS_HEALTH_MULTIPLIER; // Much higher health
                this.maxHealth = this.health; // For health bar calculation
                this.points = 5000; // High points for defeating boss
                this.speedX = 1; // Initial horizontal speed
                this.speedY = 0.05; // Slow vertical descent
                this.directionX = Math.random() < 0.5 ? 1 : -1;

                this.attackCooldown = BOSS_ATTACK_COOLDOWN; // Boss attacks every 1.5 seconds
                this.lastAttackTime = performance.now();

                // REMOVED: Sprite animation properties as the image is a single frame
                // this.frameX = 0;
                // this.frameY = 0;
                // this.frameWidth = 60;
                // this.frameHeight = 60;
                // this.maxFrames = 4;
                // this.frameTimer = 0;
                // this.frameInterval = 150;
            }

            draw() {
                // Draw the entire boss image (no sprite sheet logic needed)
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);

                // Draw the health bar for the boss
                const healthBarWidth = this.width * (this.health / this.maxHealth);
                ctx.fillStyle = '#e74c3c'; // Red health bar
                ctx.fillRect(this.x, this.y - 15, healthBarWidth, 10);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - 15, this.width, 10);
            }

            update() {
                if (!enemiesAreFrozen) { // Boss also freezes
                    this.x += this.speedX * this.directionX;
                    this.y += this.speedY;

                    // REMOVED: Sprite animation update logic
                    // this.frameTimer += 1000 / 60;
                    // if (this.frameTimer > this.frameInterval) {
                    //     this.frameX++;
                    //     if (this.frameX >= this.maxFrames) {
                    //         this.frameX = 0;
                    //     }
                    //     this.frameTimer -= this.frameInterval;
                    // }

                    // Bounce off walls
                    if (this.x + this.width > GAME_WIDTH || this.x < 0) {
                        this.directionX *= -1;
                    }

                    // Boss attacks
                    const now = performance.now();
                    if (now - this.lastAttackTime > this.attackCooldown) {
                        this.shootAttack();
                        this.lastAttackTime = now;
                    }

                    // Game over if boss reaches guillotine
                    if (this.y + this.height > guillotine.y) {
                        endGame();
                        return; // Stop game loop immediately
                    }
                }
            }

            shootAttack() {
                // Boss can fire multiple projectiles or a burst
                // Example: 3 projectiles in a small arc
                bossProjectiles.push(new BossProjectile(this.x + this.width / 2, this.y + this.height, -0.5));
                bossProjectiles.push(new BossProjectile(this.x + this.width / 2, this.y + this.height, 0));
                bossProjectiles.push(new BossProjectile(this.x + this.width / 2, this.y + this.height, 0.5));
            }

            takeHit() {
                this.health--;
            }
        }

        class BossProjectile {
            constructor(x, y, dx = 0) {
                this.x = x;
                this.y = y;
                this.width = PROJECTILE_WIDTH * 1.5; // Slightly larger than player projectiles
                this.height = PROJECTILE_HEIGHT * 1.5;
                this.speed = 4; // Slower than player projectiles, easier to dodge
                this.dx = dx * (this.speed / 2); // Horizontal speed component
            }

            draw() {
                ctx.fillStyle = '#ff0000'; // Red for boss projectiles
                ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height); // Center the projectile
            }

            update() {
                this.y += this.speed; // Moves downwards
                this.x += this.dx;
            }
        }


        // Questions for the game (NEW QUESTIONS)
        const questions = [
            // Nuevas preguntas: Conjuntos nulos y "casi seguramente" (a.s.) en Probabilidad
            {
                question: "驴Qu茅 significa que un evento ocurra 'casi seguramente'?",
                options: [
                    { text: "A) Ocurre en todos los casos posibles", isCorrect: false, explanation: "Casi seguramente permite excepciones en conjuntos de probabilidad cero." },
                    { text: "B) Su complemento tiene probabilidad cero", isCorrect: true, explanation: "Un evento ocurre casi seguramente si la probabilidad de que no ocurra es cero." },
                    { text: "C) Tiene probabilidad uno y es un evento at贸mico", isCorrect: false, explanation: "No necesariamente es at贸mico, y probabilidad uno no siempre implica 'casi seguramente' si el espacio no es completo." },
                    { text: "D) Es determinista", isCorrect: false, explanation: "No implica determinismo, solo que la probabilidad de fallo es nula." }
                ],
                level: 7
            },
            {
                question: "Si un evento tiene probabilidad cero, entonces:",
                options: [
                    { text: "A) Puede ocurrir, pero con probabilidad nula", isCorrect: true, explanation: "Un evento de probabilidad cero no es imposible, solo extremadamente improbable en un sentido formal." },
                    { text: "B) Nunca puede ocurrir", isCorrect: false, explanation: "Esto es falso en espacios de probabilidad continuos, donde puntos individuales tienen probabilidad cero pero pueden ocurrir." },
                    { text: "C) Es igual al conjunto vac铆o", isCorrect: false, explanation: "Un evento de probabilidad cero no es necesariamente el conjunto vac铆o." },
                    { text: "D) No es medible", isCorrect: false, explanation: "Para que un evento tenga probabilidad, debe ser medible." }
                ],
                level: 7
            },
            {
                question: "Si dos variables aleatorias son iguales casi seguramente, entonces:",
                options: [
                    { text: "A) Son id茅nticas como funciones", isCorrect: false, explanation: "Pueden diferir en un conjunto de medida cero." },
                    { text: "B) Coinciden excepto en un conjunto de probabilidad cero", isCorrect: true, explanation: "Esta es la definici贸n de igualdad casi segura." },
                    { text: "C) Son independientes", isCorrect: false, explanation: "La igualdad casi segura no implica independencia." },
                    { text: "D) Tienen diferentes distribuciones", isCorrect: false, explanation: "Tienen la misma distribuci贸n si son iguales casi seguramente." }
                ],
                level: 7
            },
            {
                question: "驴Qu茅 se puede decir de una variable aleatoria que es igual a cero casi seguramente?",
                options: [
                    { text: "A) Es cero fuera de un conjunto de probabilidad cero", isCorrect: true, explanation: "Esto es la definici贸n de ser cero casi seguramente." },
                    { text: "B) Tiene valor cero en todo su dominio", isCorrect: false, explanation: "Puede tomar valores distintos de cero en un conjunto de probabilidad cero." },
                    { text: "C) Tiene media cero", isCorrect: false, explanation: "No necesariamente, si la integral no est谩 definida, o si es cero a.s. pero no integrable." },
                    { text: "D) No es integrable", isCorrect: false, explanation: "Una funci贸n cero casi seguramente es integrable y su integral es cero." }
                ],
                level: 7
            },
            {
                question: "La expresi贸n 'X igual a Y casi seguramente' implica que:",
                options: [
                    { text: "A) X y Y tienen la misma media", isCorrect: false, explanation: "Aunque a menudo es cierto, no es la definici贸n directa." },
                    { text: "B) X y Y son iguales salvo en un conjunto de probabilidad cero", isCorrect: true, explanation: "Esta es la definici贸n precisa de igualdad casi segura." },
                    { text: "C) X y Y son constantes", isCorrect: false, explanation: "No, pueden ser variables aleatorias no constantes." },
                    { text: "D) X y Y son independientes", isCorrect: false, explanation: "No hay relaci贸n directa con la independencia." }
                ],
                level: 7
            },
            {
                question: "驴Cu谩l de los siguientes enunciados describe un evento nulo?",
                options: [
                    { text: "A) Su probabilidad es uno", isCorrect: false, explanation: "Esto describe un evento seguro." },
                    { text: "B) Su probabilidad es cero", isCorrect: true, explanation: "Un evento nulo es aquel cuya probabilidad es cero." },
                    { text: "C) Es seguro", isCorrect: false, explanation: "Un evento seguro tiene probabilidad uno." },
                    { text: "D) Ocurre con frecuencia", isCorrect: false, explanation: "Los eventos nulos son raros o no ocurren en un sentido pr谩ctico." }
                ],
                level: 7
            },
            {
                question: "Si P(A) = 0, entonces para cualquier evento B:",
                options: [
                    { text: "A) P(A intersecci贸n B) = 0", isCorrect: true, explanation: "Si A es un evento nulo, su intersecci贸n con cualquier otro evento tambi茅n es nula." },
                    { text: "B) P(A uni贸n B) = P(B)", isCorrect: false, explanation: "Esto es cierto, pero la opci贸n A es una implicaci贸n m谩s directa de P(A)=0." },
                    { text: "C) A y B son independientes", isCorrect: false, explanation: "No se puede asumir independencia solo porque P(A)=0." },
                    { text: "D) B es tambi茅n nulo", isCorrect: false, explanation: "B puede ser cualquier evento, no necesariamente nulo." }
                ],
                level: 7
            },
            {
                question: "En t茅rminos probabil铆sticos, decir que una propiedad se cumple 'casi seguramente' es equivalente a decir que:",
                options: [
                    { text: "A) Se cumple fuera de un conjunto de probabilidad cero", isCorrect: true, explanation: "Esta es la definici贸n est谩ndar de 'casi seguramente'." },
                    { text: "B) Se cumple en todos los puntos", isCorrect: false, explanation: "Esto ser铆a 'en todo el espacio', no 'casi seguramente'." },
                    { text: "C) Se cumple en al menos un punto", isCorrect: false, explanation: "Esto es una condici贸n muy d茅bil." },
                    { text: "D) Se cumple con media uno", isCorrect: false, explanation: "La media no est谩 directamente relacionada con la ocurrencia casi segura." }
                ],
                level: 7
            },
            {
                question: "Si una sucesi贸n de eventos An satisface que la uni贸n de todos los An tiene probabilidad cero, entonces:",
                options: [
                    { text: "A) Casi seguramente, ninguno de los An ocurre", isCorrect: true, explanation: "Si la uni贸n tiene probabilidad cero, entonces casi seguramente ning煤n evento individual An ocurre." },
                    { text: "B) Todos los An son vac铆os", isCorrect: false, explanation: "Los eventos An pueden no ser vac铆os, pero su probabilidad es cero." },
                    { text: "C) Todos los An ocurren", isCorrect: false, explanation: "Esto es lo opuesto." },
                    { text: "D) La probabilidad de su intersecci贸n es uno", isCorrect: false, explanation: "No hay relaci贸n directa con la intersecci贸n." }
                ],
                level: 7
            },
            {
                question: "Si una variable aleatoria converge a otra casi seguramente, entonces:",
                options: [
                    { text: "A) Converge en media", isCorrect: false, explanation: "La convergencia casi segura no implica necesariamente convergencia en media sin condiciones adicionales (como dominaci贸n)." },
                    { text: "B) Converge punto a punto fuera de un conjunto de probabilidad cero", isCorrect: true, explanation: "Esta es la definici贸n de convergencia casi segura." },
                    { text: "C) Converge uniformemente", isCorrect: false, explanation: "La convergencia casi segura es m谩s d茅bil que la uniforme." },
                    { text: "D) Converge d茅bil", isCorrect: false, explanation: "La convergencia casi segura implica convergencia en probabilidad, que es m谩s fuerte que la convergencia d茅bil." }
                ],
                level: 7
            },
            // Eventos de probabilidad cero y sus implicaciones
            {
                question: "驴Puede una variable aleatoria tomar un valor con probabilidad cero?",
                options: [
                    { text: "A) S铆, en variables continuas", isCorrect: true, explanation: "Para variables aleatorias continuas, la probabilidad de que tomen un valor exacto es cero." },
                    { text: "B) No, es imposible", isCorrect: false, explanation: "Es posible en variables continuas." },
                    { text: "C) Solo si es discreta", isCorrect: false, explanation: "En discretas, los valores con probabilidad cero no se consideran en el rango." },
                    { text: "D) Solo si es constante", isCorrect: false, explanation: "No, aplica a variables continuas en general." }
                ],
                level: 7
            },
            {
                question: "En un espacio de probabilidad, 驴cu谩l es el valor m谩ximo que puede tener un conjunto nulo?",
                options: [
                    { text: "A) Uno", isCorrect: false, explanation: "Un conjunto nulo tiene probabilidad cero." },
                    { text: "B) Cero", isCorrect: true, explanation: "Por definici贸n, un conjunto nulo tiene medida (probabilidad) cero." },
                    { text: "C) Menor que uno", isCorrect: false, explanation: "Es exactamente cero." },
                    { text: "D) Infinita", isCorrect: false, explanation: "La probabilidad es siempre finita (entre 0 y 1)." }
                ],
                level: 7
            },
            {
                question: "驴Cu谩l de los siguientes ejemplos puede representar un evento de probabilidad cero?",
                options: [
                    { text: "A) Que una variable continua tome un valor espec铆fico", isCorrect: true, explanation: "En distribuciones continuas, la probabilidad de un punto es cero." },
                    { text: "B) Que un dado d茅 un n煤mero impar", isCorrect: false, explanation: "Esto tiene probabilidad 1/2." },
                    { text: "C) Que la suma de dos dados sea mayor que dos", isCorrect: false, explanation: "Esto tiene una probabilidad alta (35/36)." },
                    { text: "D) Que una moneda d茅 cara", isCorrect: false, explanation: "Esto tiene probabilidad 1/2." }
                ],
                level: 7
            },
            {
                question: "驴Qu茅 propiedad cumple una funci贸n indicadora de un evento de probabilidad cero?",
                options: [
                    { text: "A) Tiene valor uno en todo su dominio", isCorrect: false, explanation: "Solo toma valor uno en el evento." },
                    { text: "B) Su valor esperado es cero", isCorrect: true, explanation: "El valor esperado de una indicadora es la probabilidad del evento, que es cero para un evento nulo." },
                    { text: "C) No es integrable", isCorrect: false, explanation: "Las indicadoras son siempre integrables." },
                    { text: "D) Su varianza es negativa", isCorrect: false, explanation: "La varianza es siempre no negativa." }
                ],
                level: 7
            },
            {
                question: "En procesos estoc谩sticos, una trayectoria que viola una propiedad con probabilidad cero:",
                options: [
                    { text: "A) Es te贸ricamente posible, pero despreciable", isCorrect: true, explanation: "Aunque es posible en el espacio de resultados, su ocurrencia es 'despreciable' en el sentido de la medida." },
                    { text: "B) Es la trayectoria m谩s probable", isCorrect: false, explanation: "Es lo contrario." },
                    { text: "C) Se repite con frecuencia", isCorrect: false, explanation: "No se repite con frecuencia si tiene probabilidad cero." },
                    { text: "D) Tiene media infinita", isCorrect: false, explanation: "La media no est谩 directamente relacionada con la probabilidad de la trayectoria." }
                ],
                level: 7
            },
            // Relaciones con independencia, convergencia y funciones aleatorias
            {
                question: "Si una propiedad ocurre casi seguramente para cada elemento de una sucesi贸n de variables independientes, entonces:",
                options: [
                    { text: "A) Ocurre fuera de un conjunto de probabilidad cero", isCorrect: true, explanation: "Si ocurre casi seguramente, por definici贸n, se cumple fuera de un conjunto de probabilidad cero." },
                    { text: "B) Solo ocurre si son id茅nticas", isCorrect: false, explanation: "No se requiere que sean id茅nticas." },
                    { text: "C) Es imposible", isCorrect: false, explanation: "Es una afirmaci贸n sobre la ocurrencia." },
                    { text: "D) La probabilidad total es infinita", isCorrect: false, explanation: "La probabilidad total es siempre uno." }
                ],
                level: 7
            },
            {
                question: "Dos variables que son iguales casi seguramente:",
                options: [
                    { text: "A) Siempre tienen la misma varianza", isCorrect: false, explanation: "Pueden tener la misma varianza, pero la igualdad casi segura se refiere a la coincidencia de valores." },
                    { text: "B) Tienen la misma distribuci贸n", isCorrect: true, explanation: "Si dos variables aleatorias son iguales casi seguramente, tienen la misma distribuci贸n." },
                    { text: "C) Son independientes", isCorrect: false, explanation: "La igualdad casi segura no implica independencia." },
                    { text: "D) Son constantes", isCorrect: false, explanation: "No necesariamente, pueden ser variables no constantes." }
                ],
                level: 7
            },
            {
                question: "La convergencia casi segura de una sucesi贸n de variables aleatorias garantiza:",
                options: [
                    { text: "A) Convergencia fuera de un conjunto de probabilidad cero", isCorrect: true, explanation: "Esta es la definici贸n de convergencia casi segura." },
                    { text: "B) Convergencia uniforme", isCorrect: false, explanation: "La convergencia casi segura es m谩s d茅bil que la uniforme." },
                    { text: "C) Convergencia de la esperanza", isCorrect: false, explanation: "No garantiza la convergencia de la esperanza sin condiciones adicionales (como dominaci贸n)." },
                    { text: "D) Convergencia d茅bil", isCorrect: false, explanation: "La convergencia casi segura implica convergencia en probabilidad, que es m谩s fuerte que la convergencia d茅bil." }
                ],
                level: 7
            },
            {
                question: "Si X converge casi seguramente a Y, entonces:",
                options: [
                    { text: "A) La probabilidad de que X y Y difieran infinitamente muchas veces es cero", isCorrect: true, explanation: "Esto es una formulaci贸n equivalente de la convergencia casi segura." },
                    { text: "B) X y Y son iguales", isCorrect: false, explanation: "Pueden diferir en un conjunto de probabilidad cero." },
                    { text: "C) X tiene mayor media", isCorrect: false, explanation: "No hay relaci贸n con la media." },
                    { text: "D) No se puede integrar", isCorrect: false, explanation: "La integrabilidad no se ve afectada por la convergencia." }
                ],
                level: 7
            },
            {
                question: "En una integral de esperanza, 驴qu茅 efecto tiene una diferencia que ocurre solo en un conjunto nulo?",
                options: [
                    { text: "A) No cambia el valor de la integral", isCorrect: true, explanation: "Las integrales de Lebesgue son invariantes bajo cambios en conjuntos de medida cero." },
                    { text: "B) Aumenta la varianza", isCorrect: false, explanation: "No afecta la varianza." },
                    { text: "C) Cambia la distribuci贸n", isCorrect: false, explanation: "No cambia la distribuci贸n." },
                    { text: "D) Hace la integral divergente", isCorrect: false, explanation: "No la hace divergente." }
                ],
                level: 7
            },
            // Interpretaciones y consecuencias en modelos probabil铆sticos
            {
                question: "En teor铆a de la probabilidad, 驴por qu茅 se permite ignorar eventos de probabilidad cero?",
                options: [
                    { text: "A) Porque no afectan c谩lculos de esperanza ni distribuci贸n", isCorrect: true, explanation: "Los eventos de probabilidad cero no influyen en propiedades como la esperanza, varianza o distribuci贸n." },
                    { text: "B) Porque no son medibles", isCorrect: false, explanation: "Para tener probabilidad, deben ser medibles." },
                    { text: "C) Porque ocurren siempre", isCorrect: false, explanation: "Es lo contrario." },
                    { text: "D) Porque son infinitos", isCorrect: false, explanation: "Su tama帽o no es la raz贸n principal." }
                ],
                level: 7
            },
            {
                question: "Si una funci贸n f(x) es cero casi seguramente, 驴qu茅 se cumple?",
                options: [
                    { text: "A) f(x) no es medible", isCorrect: false, explanation: "Para ser cero casi seguramente, debe ser medible." },
                    { text: "B) La esperanza de f es cero", isCorrect: true, explanation: "Si una funci贸n es cero casi seguramente, su integral (esperanza) es cero." },
                    { text: "C) f(x) es constante en todo el espacio", isCorrect: false, explanation: "Puede no ser constante en el conjunto de medida cero." },
                    { text: "D) f(x) toma valores negativos", isCorrect: false, explanation: "No hay relaci贸n con los valores negativos." }
                ],
                level: 7
            },
            {
                question: "驴Qu茅 significa que dos funciones sean iguales casi seguramente en el contexto de variables aleatorias?",
                options: [
                    { text: "A) Son iguales en todos los puntos", isCorrect: false, explanation: "Pueden diferir en un conjunto de probabilidad cero." },
                    { text: "B) Son iguales excepto en un conjunto con probabilidad cero", isCorrect: true, explanation: "Esta es la definici贸n." },
                    { text: "C) Tienen la misma media", isCorrect: false, explanation: "Aunque a menudo es cierto, no es la definici贸n directa." },
                    { text: "D) Tienen diferente varianza", isCorrect: false, explanation: "Tienen la misma varianza." }
                ],
                level: 7
            },
            {
                question: "Si una funci贸n g toma un valor distinto en un conjunto de probabilidad cero, entonces:",
                options: [
                    { text: "A) g puede considerarse igual a otra funci贸n con valor diferente solo en ese conjunto", isCorrect: true, explanation: "Para prop贸sitos de integraci贸n y propiedades probabil铆sticas, estas funciones son equivalentes." },
                    { text: "B) g no es integrable", isCorrect: false, explanation: "La integrabilidad no se ve afectada por valores en conjuntos de medida cero." },
                    { text: "C) g cambia su esperanza", isCorrect: false, explanation: "No cambia su esperanza." },
                    { text: "D) g es constante", isCorrect: false, explanation: "No necesariamente." }
                ],
                level: 7
            },
            {
                question: "La probabilidad de un subconjunto de medida cero en el continuo es:",
                options: [
                    { text: "A) Uno", isCorrect: false, explanation: "Es cero." },
                    { text: "B) Cero", isCorrect: true, explanation: "Por definici贸n, un conjunto de medida cero tiene probabilidad cero." },
                    { text: "C) Mayor que uno", isCorrect: false, explanation: "La probabilidad no puede ser mayor que uno." },
                    { text: "D) Infinita", isCorrect: false, explanation: "La probabilidad es finita." }
                ],
                level: 7
            }
        ];

        let currentQuestion = null;
        let answeredQuestions = new Set(); // To keep track of questions already asked

        // Utility function to shuffle an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
            return array;
        }

        // Game Functions
        async function initGame() {
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            guillotine = new Guillotine();
            projectiles = [];
            enemies = [];
            obstacles = []; // Initialize obstacles array
            powerUps = []; // Initialize power-ups array
            drones = []; // Initialize drones array
            boss = null; // Reset boss
            bossProjectiles = []; // Reset boss projectiles
            score = 0;
            level = 1;
            currentWave = 1;
            wavesClearedTotal = 0; // Reset total waves cleared
            isGameOver = false;
            gamePaused = false;
            enemiesDefeatedThisLevel = 0;
            answeredQuestions.clear();

            // Store original values for power-up reset
            originalShootCooldown = 500;
            currentProjectileWidth = PROJECTILE_WIDTH;
            currentProjectileHeight = PROJECTILE_HEIGHT;
            guillotine.currentShootCooldown = originalShootCooldown; // Ensure initial cooldown is set

            activePowerUp = null; // No active power-up at start
            powerUpEndTime = 0;
            enemiesAreFrozen = false; // Ensure enemies are not frozen at start
            freezeEndTime = 0; // Reset freeze end time
            activePowerUpDisplay.textContent = 'Poder Activo: Ninguno'; // Reset power-up display

            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            currentWaveDisplay.textContent = currentWave;
            // Set total waves for level 1 initially
            totalWavesInLevel = levelConfigs[0].numWaves;
            totalWavesInLevelDisplay.textContent = totalWavesInLevel;
            enemiesRemainingDisplay.textContent = 0; // Reset for initial display
            gameOverOverlay.style.display = 'none';
            questionModal.style.display = 'none';

            // Initialize Firebase and load high score
            await window.initFirebase();
            await window.loadHighScore(); // This will update highScoreDisplay

            spawnWave(); // Call spawnWave instead of spawnEntities for the first wave
            triggerQuestion(); // Trigger first question for Level 1
            startGameLoop();

            // Attempt to play music on game start
            try {
                // The browser might block autoplay without user interaction.
                // If it doesn't play automatically, click the "M煤sica: ON" button.
                await backgroundMusic.play();
                musicToggleBtn.textContent = 'M煤sica: ON';
            } catch (error) {
                console.warn("Autoplay was prevented. User must interact to play music.", error);
                musicToggleBtn.textContent = 'M煤sica: OFF';
            }
        }

        function spawnWave() {
            enemies = [];
            obstacles = []; // Clear obstacles for new wave
            powerUps = []; // Clear power-ups for new wave
            drones = []; // Clear drones for new wave (drones are tied to power-up duration, but clear on new wave for simplicity)

            const currentLevelConfig = levelConfigs[level - 1]; // Get config for current level
            if (!currentLevelConfig) {
                console.error(`No level config found for level ${level}. Ending game.`);
                endGame();
                return;
            }

            const enemyTypes = ['crown', 'crown', 'louis', 'marie', 'triangle'];

            // Adjust enemy/obstacle size based on level config
            const currentEnemyWidth = ENEMY_BASE_WIDTH * currentLevelConfig.enemySizeMultiplier;
            const currentEnemyHeight = ENEMY_BASE_HEIGHT * currentLevelConfig.enemySizeMultiplier;

            // Calculate grid dimensions based on number of entities for this wave
            const numEntitiesForWave = currentLevelConfig.baseEnemiesPerWave + currentLevelConfig.baseObstaclesPerWave;
            // A simple way to arrange them: calculate rows/cols to fit N entities
            const estimatedCols = Math.min(10, Math.ceil(Math.sqrt(numEntitiesForWave * 1.5))); // Try to make it somewhat square-ish
            const estimatedRows = Math.ceil(numEntitiesForWave / estimatedCols);

            const dynamicEntitySpacingX = Math.max(currentEnemyWidth + 10, INITIAL_ENEMY_SPACING_X - (level - 1) * 3);
            const dynamicEntitySpacingY = Math.max(currentEnemyHeight + 10, INITIAL_ENEMY_SPACING_Y - (level - 1) * 3);

            const totalGridWidth = estimatedCols * dynamicEntitySpacingX - (dynamicEntitySpacingX - currentEnemyWidth);
            const dynamicStartX = (GAME_WIDTH - totalGridWidth) / 2;
            const dynamicStartY = ENEMY_START_Y;

            // Power-up drop chance for this level
            const powerUpDropChance = currentLevelConfig.powerUpDropChance;
            const rockSpawnChance = currentLevelConfig.rockSpawnChance;
            const indestructibleRockChance = currentLevelConfig.indestructibleRockChance;

            let entitiesSpawnedInWave = 0;
            const maxEntitiesToSpawn = currentLevelConfig.baseEnemiesPerWave + currentLevelConfig.baseObstaclesPerWave;

            // Spawn entities for the current wave
            for (let r = 0; r < estimatedRows && entitiesSpawnedInWave < maxEntitiesToSpawn; r++) {
                for (let c = 0; c < estimatedCols && entitiesSpawnedInWave < maxEntitiesToSpawn; c++) {
                    const entityX = dynamicStartX + c * dynamicEntitySpacingX + (Math.random() - 0.5) * 10;
                    const entityY = dynamicStartY + r * dynamicEntitySpacingY;

                    if (Math.random() < rockSpawnChance) {
                        const rockType = Math.random() < indestructibleRockChance ? 'indestructible_rock' : 'destructible_rock';
                        obstacles.push(new Obstacle(entityX, entityY, rockType, currentEnemyWidth, currentEnemyHeight, currentLevelConfig.enemySpeedMultiplier));
                    } else {
                        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                        enemies.push(new Enemy(entityX, entityY, type, currentEnemyWidth, currentEnemyHeight, currentLevelConfig.enemySpeedMultiplier));
                    }
                    entitiesSpawnedInWave++;
                }
            }

            // Ensure at least one entity is spawned if nothing was generated
            if (entitiesSpawnedInWave === 0 && maxEntitiesToSpawn > 0) {
                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                enemies.push(new Enemy(GAME_WIDTH / 2 - currentEnemyWidth / 2, ENEMY_START_Y, type, currentEnemyWidth, currentEnemyHeight, currentLevelConfig.enemySpeedMultiplier));
            }

            enemiesRemainingDisplay.textContent = enemies.length + obstacles.filter(o => !o.isIndestructible).length;
        }

        function spawnBoss() {
            boss = new Boss();
            enemies = []; // Clear any regular enemies
            obstacles = []; // Clear any obstacles
            powerUps = []; // Clear any power-ups
            drones = []; // Clear any drones
            bossProjectiles = []; // Clear any existing boss projectiles

            const currentLevelConfig = levelConfigs[level - 1];
            const enemySpeedMultiplier = currentLevelConfig ? currentLevelConfig.enemySpeedMultiplier : 0.5;
            const enemyWidth = ENEMY_BASE_WIDTH * (currentLevelConfig ? currentLevelConfig.enemySizeMultiplier : 1);
            const enemyHeight = ENEMY_BASE_HEIGHT * (currentLevelConfig ? currentLevelConfig.enemySizeMultiplier : 1);

            // Spawn Louis XVI with Rapid Fire power-up
            enemies.push(new Enemy(GAME_WIDTH * 0.2, ENEMY_START_Y + 50, 'louis', enemyWidth, enemyHeight, enemySpeedMultiplier, true, 'rapid_fire'));
            // Spawn a Destructible Rock with Triple Shot power-up
            obstacles.push(new Obstacle(GAME_WIDTH * 0.7, ENEMY_START_Y + 50, 'destructible_rock', enemyWidth, enemyHeight, enemySpeedMultiplier, true, 'triple_shot'));

            // You can still add other regular enemies if you want more challenge during the boss phase
            enemies.push(new Enemy(GAME_WIDTH * 0.1, ENEMY_START_Y + 20, 'crown', enemyWidth, enemyHeight, enemySpeedMultiplier, true));
            enemies.push(new Enemy(GAME_WIDTH * 0.4, ENEMY_START_Y + 20, 'marie', enemyWidth, enemyHeight, enemySpeedMultiplier, true));


            // Update display to reflect boss fight
            enemiesRemainingDisplay.textContent = "隆JEFE!";
            activePowerUpDisplay.textContent = "隆Cuidado!"; // Reset power-up display, as they need to be collected
            gamePaused = false; // Ensure game is unpaused for boss fight
            startGameLoop();
        }


        function startGameLoop() {
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
            }
            gameLoop();
        }

        // Function to check if the current wave is completed and handle transitions
        function checkWaveCompletion() {
            // Check if all regular enemies and destructible obstacles are defeated
            const remainingDestructibleEntities = enemies.length + obstacles.filter(o => !o.isIndestructible).length;

            if (boss) {
                // If there's a boss, wave completion is tied to boss defeat
                return; // Do nothing, boss logic handles progression
            }

            if (remainingDestructibleEntities === 0) {
                wavesClearedTotal++; // Increment total waves cleared

                const currentLevelConfig = levelConfigs[level - 1];

                if (wavesClearedTotal % BOSS_WAVE_INTERVAL === 0) {
                    // Time for a boss fight!
                    gamePaused = true; // Pause briefly before boss appears
                    setTimeout(() => {
                        spawnBoss();
                        gamePaused = false; // Unpause for boss fight
                        startGameLoop();
                    }, 2000); // Small delay before boss spawns
                } else if (currentWave < currentLevelConfig.numWaves) {
                    // Advance to next regular wave
                    currentWave++;
                    currentWaveDisplay.textContent = currentWave;
                    gamePaused = true; // Pause game during wave transition
                    setTimeout(() => {
                        spawnWave();
                        gamePaused = false; // Unpause after wave spawns
                        startGameLoop();
                    }, currentLevelConfig.waveDelay); // Small delay before next wave
                } else {
                    // All waves completed for the current level, level up!
                    levelUp();
                }
            }
        }

        function gameLoop() {
            if (isGameOver) {
                return;
            }
            if (gamePaused) {
                gameLoopId = requestAnimationFrame(gameLoop); // Keep requesting frames to unpause
                return;
            }

            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT); // Clear canvas

            guillotine.draw();

            // Store indices of entities to be removed
            let enemiesToRemove = new Set();
            let projectilesToRemove = new Set();
            let obstaclesToRemove = new Set();
            let powerUpsToRemove = new Set(); // New set for power-ups to remove

            // Update and draw boss (if active)
            if (boss) {
                boss.update();
                boss.draw();

                // Process player projectiles
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    p.update(); // ALWAYS update projectile position
                    p.draw();   // ALWAYS draw projectile

                    // Check if projectile is off-screen
                    if (p.y + p.height < 0 || p.x < -PROJECTILE_WIDTH || p.x > GAME_WIDTH) {
                        projectiles.splice(i, 1);
                        continue; // Move to the next projectile
                    }

                    // Check collision with boss
                    if (checkCollision(p, boss)) {
                        boss.takeHit();
                        if (!p.isPiercing) {
                            projectiles.splice(i, 1); // Remove non-piercing projectile
                        }
                        if (boss.health <= 0) {
                            score += boss.points;
                            scoreDisplay.textContent = score;
                            boss = null; // Boss defeated!
                            // Clear remaining boss projectiles
                            bossProjectiles = [];
                            gamePaused = true; // Pause for transition
                            setTimeout(() => {
                                levelUp(); // Proceed to next level
                                gamePaused = false;
                                startGameLoop();
                            }, 2000); // Small delay before next level
                            break; // Exit player projectile loop as boss is defeated
                        }
                    }
                }

                // Update and draw boss projectiles
                for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                    const bp = bossProjectiles[i];
                    bp.update();
                    bp.draw();

                    // Check collision with guillotine
                    if (checkCollision(guillotine, bp)) {
                        endGame(); // Game over if boss projectile hits guillotine
                        return; // Stop game loop immediately
                    }

                    // Remove if off-screen
                    if (bp.y > GAME_HEIGHT) {
                        bossProjectiles.splice(i, 1);
                    }
                }
            } else { // Only process regular enemies/obstacles if no boss is active
                // Update projectiles and check for collisions (against regular enemies/obstacles)
                for (let i = 0; i < projectiles.length; i++) {
                    const projectile = projectiles[i];
                    projectile.update();

                    // Mark projectile for removal if it goes off screen
                    if (projectile.y + projectile.height < 0 || projectile.x < -PROJECTILE_WIDTH || projectile.x > GAME_WIDTH) {
                        projectilesToRemove.add(i);
                        continue;
                    }

                    let hitThisProjectile = false; // Flag to track if this projectile hit anything (for non-piercing)

                    // Check for collisions with enemies
                    for (let j = 0; j < enemies.length; j++) {
                        const enemy = enemies[j];
                        if (checkCollision(projectile, enemy)) {
                            score += enemy.points;
                            scoreDisplay.textContent = score;
                            enemiesDefeatedThisLevel++;
                            enemiesToRemove.add(j);

                            // Power-up drop logic for enemies
                            if (enemy.guaranteedPowerUpDrop) {
                                const typeToDrop = enemy.powerUpTypeToDrop || Object.keys(POWER_UP_TYPES)[Math.floor(Math.random() * Object.keys(POWER_UP_TYPES).length)];
                                powerUps.push(new PowerUp(enemy.x + enemy.width / 2 - POWER_UP_WIDTH / 2, enemy.y + enemy.height / 2 - POWER_UP_HEIGHT / 2, typeToDrop));
                            } else {
                                const currentLevelConfig = levelConfigs[level - 1];
                                const powerUpDropChance = currentLevelConfig ? currentLevelConfig.powerUpDropChance : 0.01; // Default low chance
                                if (Math.random() < powerUpDropChance) {
                                    const randomPowerUpType = Object.keys(POWER_UP_TYPES)[Math.floor(Math.random() * Object.keys(POWER_UP_TYPES).length)];
                                    powerUps.push(new PowerUp(enemy.x + enemy.width / 2 - POWER_UP_WIDTH / 2, enemy.y + enemy.height / 2 - POWER_UP_HEIGHT / 2, randomPowerUpType));
                                }
                            }

                            if (!projectile.isPiercing) { // Only destroy projectile if not piercing
                                projectilesToRemove.add(i);
                                hitThisProjectile = true;
                                break; // Stop checking enemies for this projectile if it's not piercing
                            }
                        }
                    }
                    if (hitThisProjectile) continue; // If non-piercing hit an enemy, move to next projectile

                    // Check for collisions with obstacles
                    for (let k = 0; k < obstacles.length; k++) {
                        const obstacle = obstacles[k];
                        if (checkCollision(projectile, obstacle)) {
                            if (obstacle.isIndestructible) {
                                projectilesToRemove.add(i); // Projectile always destroyed by hitting an indestructible obstacle
                                hitThisProjectile = true;
                            } else { // Destructible rock
                                obstacle.takeHit();
                                if (obstacle.health <= 0) {
                                    obstaclesToRemove.add(k);
                                    score += obstacle.points; // Add points for destroying obstacles

                                    // Power-up drop logic for destructible obstacles
                                    if (obstacle.guaranteedPowerUpDrop) {
                                        const typeToDrop = obstacle.powerUpTypeToDrop || Object.keys(POWER_UP_TYPES)[Math.floor(Math.random() * Object.keys(POWER_UP_TYPES).length)];
                                        powerUps.push(new PowerUp(obstacle.x + obstacle.width / 2 - POWER_UP_WIDTH / 2, obstacle.y + obstacle.height / 2 - POWER_UP_HEIGHT / 2, typeToDrop));
                                    } else {
                                        const currentLevelConfig = levelConfigs[level - 1];
                                        const powerUpDropChance = currentLevelConfig ? currentLevelConfig.powerUpDropChance : 0.01; // Default low chance
                                        if (Math.random() < powerUpDropChance) {
                                            const randomPowerUpType = Object.keys(POWER_UP_TYPES)[Math.floor(Math.random() * Object.keys(POWER_UP_TYPES).length)];
                                            powerUps.push(new PowerUp(obstacle.x + obstacle.width / 2 - POWER_UP_WIDTH / 2, obstacle.y + obstacle.height / 2 - POWER_UP_HEIGHT / 2, randomPowerUpType));
                                        }
                                    }
                                }
                                if (!projectile.isPiercing) { // Only destroy projectile if not piercing
                                    projectilesToRemove.add(i);
                                    hitThisProjectile = true;
                                }
                            }
                            if (hitThisProjectile) break; // Stop checking obstacles for this projectile if it's not piercing or hit indestructible
                        }
                    }
                }

                // Filter out removed entities
                projectiles = projectiles.filter((_, index) => !projectilesToRemove.has(index));
                enemies = enemies.filter((_, index) => !enemiesToRemove.has(index));
                obstacles = obstacles.filter((_, index) => !obstaclesToRemove.has(index));

                // Update and draw remaining projectiles
                for (const projectile of projectiles) {
                    projectile.draw();
                }

                // Update and draw enemies
                for (const enemy of enemies) {
                    enemy.update();
                    enemy.draw();
                }

                // Update and draw obstacles
                for (const obstacle of obstacles) {
                    obstacle.update(); // Only destructible ones move (and freeze if active)
                    obstacle.draw();
                }

                // Update and draw power-ups, check for collection
                for (let i = 0; i < powerUps.length; i++) {
                    const powerUp = powerUps[i];
                    powerUp.update();
                    powerUp.draw();

                    // Check collision with guillotine
                    if (checkCollision(guillotine, powerUp)) {
                        applyPowerUp(powerUp.type);
                        powerUpsToRemove.add(i);
                    }

                    // Remove if off screen
                    if (powerUp.y > GAME_HEIGHT) {
                        powerUpsToRemove.add(i);
                    }
                }
                powerUps = powerUps.filter((_, index) => !powerUpsToRemove.has(index));

                // Update and draw drones
                for (const drone of drones) {
                    drone.update();
                    drone.draw();
                }
            }


            // Check for power-up expiration
            const now = performance.now();
            if (activePowerUp && now > powerUpEndTime) {
                removePowerUp();
            }
            // Check for freeze power-up expiration separately
            if (enemiesAreFrozen && now > freezeEndTime) {
                enemiesAreFrozen = false;
            }


            // Update enemies remaining display (only enemies and destructible obstacles)
            // If boss is active, display "JEFE!"
            if (!boss) {
                enemiesRemainingDisplay.textContent = enemies.length + obstacles.filter(o => !o.isIndestructible).length;
            }


            checkWaveCompletion();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function levelUp() {
            // Check if max levels reached
            if (level >= MAX_LEVELS) {
                console.log("隆Felicidades! Has completado todos los niveles.");
                endGame(true); // Game won scenario
                return;
            }

            level++;
            levelDisplay.textContent = level;
            enemiesDefeatedThisLevel = 0; // Reset count for new level
            currentWave = 1; // Reset wave for new level
            currentWaveDisplay.textContent = currentWave;

            const currentLevelConfig = levelConfigs[level - 1];
            totalWavesInLevel = currentLevelConfig.numWaves;
            totalWavesInLevelDisplay.textContent = totalWavesInLevel;

            spawnWave(); // Spawn first wave of new level
            triggerQuestion(); // Trigger a question for the new level

            // Decrease guillotine cooldown for faster shooting (base speed)
            originalShootCooldown = currentLevelConfig.guillotineCooldownReduction;
            guillotine.currentShootCooldown = originalShootCooldown; // Reset to new base cooldown
            removePowerUp(); // Ensure any active power-up is removed when leveling up
        }

        function endGame(wonGame = false) {
            isGameOver = true;
            cancelAnimationFrame(gameLoopId);
            finalScoreDisplay.textContent = score;
            gameOverOverlay.style.display = 'flex';
            backgroundMusic.pause(); // Pause music on game over

            if (wonGame) {
                document.querySelector('.game-over-text').textContent = '隆Has Restaurado la Rep煤blica!';
                document.querySelector('.game-over-text').style.color = '#2ecc71'; // Green for win
            } else {
                document.querySelector('.game-over-text').textContent = '隆La Monarqu铆a ha Ganado!';
                document.querySelector('.game-over-text').style.color = '#e74c3c'; // Red for lose
            }

            // Save high score if current score is higher
            if (score > window.highScore) {
                window.saveHighScore(score);
            }
        }

        function availableQuestionsForLevel() {
            // Filter questions to only include those from level 7 onwards
            return questions.filter(q => q.level >= 7 && !answeredQuestions.has(q));
        }

        function triggerQuestion() {
            gamePaused = true;
            let availableQs = availableQuestionsForLevel();

            if (availableQs.length > 0) {
                // Pick a random question from available ones
                currentQuestion = availableQs[Math.floor(Math.random() * availableQs.length)];
                answeredQuestions.add(currentQuestion); // Mark as asked

                questionTitle.textContent = "隆Pregunta de Medida!"; // Updated title
                questionText.textContent = currentQuestion.question;
                questionOptions.innerHTML = ''; // Clear previous options
                questionFeedback.textContent = '';
                modalContinueBtn.style.display = 'none';

                // Shuffle the options before displaying them
                const shuffledOptions = shuffleArray([...currentQuestion.options]); // Create a shallow copy to shuffle

                shuffledOptions.forEach((option, index) => {
                    const button = document.createElement('button');
                    const span = document.createElement('span'); // Create a span for MathJax
                    span.textContent = option.text; // Set the raw text including LaTeX
                    button.appendChild(span);
                    button.onclick = () => selectAnswer(option, button);
                    questionOptions.appendChild(button);
                });

                questionModal.style.display = 'flex';
                // Render MathJax after content is added to the DOM
                if (window.MathJax) {
                    MathJax.typesetPromise([questionText, questionOptions]).then(() => {
                        console.log('MathJax typeset complete for modal content');
                    }).catch((err) => console.error('MathJax typesetting failed:', err));
                }
            } else {
                // No more questions for this level or already answered all
                gamePaused = false; // Resume game if no question
                startGameLoop();
            }
        }

        function selectAnswer(selectedOption, clickedButton) {
            // Disable all options after selection
            Array.from(questionOptions.children).forEach(button => {
                button.disabled = true;
                // Find the original option object associated with this button's text (from its span)
                const originalOptionText = button.querySelector('span').textContent;
                const originalOption = currentQuestion.options.find(opt => opt.text === originalOptionText);

                if (button === clickedButton) {
                    button.classList.add(selectedOption.isCorrect ? 'correct' : 'incorrect');
                } else if (originalOption && originalOption.isCorrect) {
                    button.classList.add('correct'); // Highlight correct answer
                }
            });

            if (selectedOption.isCorrect) {
                questionFeedback.textContent = "隆Correcto! 隆Viva la Revoluci贸n!";
                questionFeedback.classList.remove('incorrect');
                questionFeedback.classList.add('correct');
                score += 100; // Bonus points for correct answer
                scoreDisplay.textContent = score;
            } else {
                questionFeedback.textContent = `Incorrecto. ${selectedOption.explanation}`;
                questionFeedback.classList.remove('correct');
                questionFeedback.classList.add('incorrect');
            }
            modalContinueBtn.style.display = 'block';
        }

        modalContinueBtn.addEventListener('click', () => {
            questionModal.style.display = 'none';
            gamePaused = false;
            startGameLoop();
        });

        // Function to handle shooting (with cooldown and power-ups)
        function handleShoot() {
            const now = performance.now();
            let effectiveCooldown = guillotine.currentShootCooldown; // Start with base cooldown

            if (activePowerUp === 'rapid_fire') {
                effectiveCooldown = Math.max(50, originalShootCooldown / 3); // Much faster shooting
            } else if (activePowerUp === 'piercing_bullet') {
                effectiveCooldown = originalShootCooldown * 1.2; // Slightly slower for piercing
            }

            if (!isGameOver && !gamePaused && (now - guillotine.lastShotTime > effectiveCooldown)) {
                if (activePowerUp === 'triple_shot') {
                    // Triple shot: vertical, 45 deg left, 45 deg right
                    guillotine.createProjectile(0, false); // Vertical (not piercing by default)
                    guillotine.createProjectile(-0.7, false); // Angled left
                    guillotine.createProjectile(0.7, false); // Angled right
                } else if (activePowerUp === 'piercing_bullet') {
                    guillotine.createProjectile(0, true); // Piercing bullet
                } else {
                    guillotine.createProjectile(0, false); // Normal shot
                }
                guillotine.lastShotTime = now;
            }
        }

        function applyPowerUp(type) {
            // If a power-up is already active, remove it first
            if (activePowerUp) {
                removePowerUp();
            }

            activePowerUp = type;
            powerUpEndTime = performance.now() + POWER_UP_TYPES[type].duration;
            activePowerUpDisplay.textContent = `Poder Activo: ${POWER_UP_TYPES[type].name}`;

            // Apply specific effects
            if (type === 'rapid_fire') {
                // Cooldown is handled in handleShoot, no direct change here
            } else if (type === 'piercing_bullet') {
                // Piercing effect is handled in gameLoop collision logic
            } else if (type === 'enemy_freeze') {
                enemiesAreFrozen = true;
                freezeEndTime = performance.now() + POWER_UP_TYPES[type].duration;
            } else if (type === 'drone_companion') {
                drones.push(new Drone(guillotine));
            }
        }

        function removePowerUp() {
            if (!activePowerUp) return; // No power-up to remove

            // Revert effects
            if (activePowerUp === 'rapid_fire') {
                // Cooldown reverts automatically in handleShoot
            } else if (activePowerUp === 'piercing_bullet') {
                // No specific projectile size change, effect handled in collision
            } else if (activePowerUp === 'enemy_freeze') {
                enemiesAreFrozen = false; // Ensure enemies unfreeze
            } else if (activePowerUp === 'drone_companion') {
                drones = []; // Remove all drones
            }
            activePowerUp = null;
            powerUpEndTime = 0;
            activePowerUpDisplay.textContent = 'Poder Activo: Ninguno'; // Update power-up display
        }


        // Event Listeners for controls (Mouse/Touch for continuous movement)
        let moveLeftInterval = null;
        let moveRightInterval = null;

        leftBtn.addEventListener('mousedown', () => {
            if (!isGameOver && !gamePaused && !moveLeftInterval) { // Prevent multiple intervals
                moveLeftInterval = setInterval(() => guillotine.moveLeft(), 20);
            }
        });
        leftBtn.addEventListener('mouseup', () => { clearInterval(moveLeftInterval); moveLeftInterval = null; });
        leftBtn.addEventListener('mouseleave', () => { clearInterval(moveLeftInterval); moveLeftInterval = null; });
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!isGameOver && !gamePaused && !moveLeftInterval) {
                moveLeftInterval = setInterval(() => guillotine.moveLeft(), 20);
            }
        }, { passive: false });
        leftBtn.addEventListener('touchend', () => { clearInterval(moveLeftInterval); moveLeftInterval = null; });
        leftBtn.addEventListener('touchcancel', () => { clearInterval(moveLeftInterval); moveLeftInterval = null; });

        rightBtn.addEventListener('mousedown', () => {
            if (!isGameOver && !gamePaused && !moveRightInterval) { // Prevent multiple intervals
                moveRightInterval = setInterval(() => guillotine.moveRight(), 20);
            }
        });
        rightBtn.addEventListener('mouseup', () => { clearInterval(moveRightInterval); moveRightInterval = null; });
        rightBtn.addEventListener('mouseleave', () => { clearInterval(moveRightInterval); moveRightInterval = null; });
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!isGameOver && !gamePaused && !moveRightInterval) {
                moveRightInterval = setInterval(() => guillotine.moveRight(), 20);
            }
        }, { passive: false });
        rightBtn.addEventListener('touchend', () => { clearInterval(moveRightInterval); moveRightInterval = null; });
        rightBtn.addEventListener('touchcancel', () => { clearInterval(moveRightInterval); moveRightInterval = null; });


        shootBtn.addEventListener('click', handleShoot); // Use the new handleShoot function

        // Keyboard controls for continuous movement
        let keyboardMoveLeftInterval = null;
        let keyboardMoveRightInterval = null;
        let keysPressed = {}; // To track currently pressed keys

        document.addEventListener('keydown', (e) => {
            if (isGameOver || gamePaused) return;

            // Prevent repeat calls if key is held down
            if (keysPressed[e.key]) return;
            keysPressed[e.key] = true;

            switch (e.key) {
                case 'ArrowLeft':
                    if (!keyboardMoveLeftInterval) {
                        keyboardMoveLeftInterval = setInterval(() => guillotine.moveLeft(), 20);
                    }
                    break;
                case 'ArrowRight':
                    if (!keyboardMoveRightInterval) {
                        keyboardMoveRightInterval = setInterval(() => guillotine.moveRight(), 20);
                    }
                    break;
                case ' ': // Spacebar to shoot
                    e.preventDefault(); // Prevent scrolling down
                    handleShoot(); // Use the new handleShoot function
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false; // Mark key as released

            switch (e.key) {
                case 'ArrowLeft':
                    clearInterval(keyboardMoveLeftInterval);
                    keyboardMoveLeftInterval = null;
                    break;
                case 'ArrowRight':
                    clearInterval(keyboardMoveRightInterval);
                    keyboardMoveRightInterval = null;
                    break;
            }
        });

        restartBtn.addEventListener('click', initGame);

        // Music toggle functionality
        musicToggleBtn.addEventListener('click', () => {
            if (backgroundMusic.paused) {
                backgroundMusic.play();
                musicToggleBtn.textContent = 'M煤sica: ON';
            } else {
                backgroundMusic.pause();
                musicToggleBtn.textContent = 'M煤sica: OFF';
            }
        });

        // Initialize game on window load
        window.onload = initGame;
    </script>
</body>
</html>