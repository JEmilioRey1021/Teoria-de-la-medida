<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>¬°Que Coman Pasteles! - El Juego de la Revoluci√≥n Francesa</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Crete+Round&display=swap'); /* For a more historical/gamey feel */

        body {
            font-family: 'Inter', sans-serif;
            background-color: #2c3e50; /* Dark blue-grey, reminiscent of historical times */
            color: #ecf0f1; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            flex-direction: column;
            padding: 1rem;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
            padding: 1.5rem;
            background-color: #34495e; /* Slightly lighter dark background for container */
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4), 0 6px 6px rgba(0, 0, 0, 0.2);
            max-width: 95vw;
            width: 100%;
            box-sizing: border-box;
        }

        @media (min-width: 768px) {
            .game-wrapper {
                flex-direction: row;
                justify-content: center;
                align-items: flex-start;
                max-width: 1000px; /* Max width for larger screens */
            }
        }

        h1 {
            font-family: 'Crete Round', serif;
            font-size: 2.5rem;
            color: #f1c40f; /* Gold-like color */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 1rem;
            text-align: center;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        canvas {
            background-color: #000; /* Game board background */
            border: 4px solid #95a5a6; /* Silver border */
            border-radius: 0.5rem;
            display: block;
            touch-action: none; /* Disable default touch actions like scrolling */
            width: 100%; /* Make canvas fluid */
            max-width: 600px; /* Max width for game canvas */
            height: 400px; /* Fixed height for game canvas */
            box-sizing: border-box;
        }

        @media (min-width: 768px) {
            canvas {
                height: 600px; /* Taller on larger screens */
            }
        }

        .game-info {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            min-width: 150px;
            padding: 1rem;
            background-color: #2c3e50;
            border-radius: 0.5rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .info-panel {
            background-color: #34495e;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            font-weight: bold;
            font-size: 1.125rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .score-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .score-icon {
            width: 24px;
            height: 24px;
            vertical-align: middle;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .control-button {
            background-color: #e74c3c; /* Red button for action */
            color: #fff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        .control-button:hover {
            background-color: #c0392b;
            transform: translateY(-2px);
        }

        .control-button:active {
            background-color: #a52a22;
            transform: translateY(0);
            box-shadow: none;
        }

        .control-button.move {
            background-color: #3498db; /* Blue for movement */
        }
        .control-button.move:hover {
            background-color: #2980b9;
        }
        .control-button.move:active {
            background-color: #21618c;
        }

        /* Modal for questions */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-content {
            background-color: #34495e;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            text-align: center;
            color: #ecf0f1;
            font-family: 'Inter', sans-serif;
        }

        .modal-content h2 {
            font-family: 'Crete Round', serif;
            font-size: 1.8rem;
            margin-bottom: 1rem;
            color: #f1c40f;
        }

        .modal-content p {
            font-size: 1.1rem;
            margin-bottom: 1.5rem;
        }

        .modal-options button {
            display: block;
            width: 100%;
            padding: 0.8rem;
            margin-bottom: 0.8rem;
            background-color: #2ecc71; /* Green for options */
            color: #fff;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .modal-options button:hover {
            background-color: #27ae60;
        }
        .modal-options button.incorrect {
            background-color: #e74c3c; /* Red for incorrect */
        }
        .modal-options button.correct {
            background-color: #27ae60; /* Green for correct */
        }

        .modal-feedback {
            margin-top: 1rem;
            font-weight: bold;
            font-size: 1.1rem;
        }
        .modal-feedback.correct {
            color: #2ecc71;
        }
        .modal-feedback.incorrect {
            color: #e74c3c;
        }

        .modal-continue-button {
            background-color: #3498db;
            color: #fff;
            padding: 0.8rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: bold;
            cursor: pointer;
            margin-top: 1.5rem;
            transition: background-color 0.2s ease-in-out;
            border: none;
            outline: none;
        }
        .modal-continue-button:hover {
            background-color: #2980b9;
        }

        .game-over-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 1.5rem;
            z-index: 1000;
            border-radius: 1rem;
            text-align: center;
        }

        .game-over-text {
            font-family: 'Crete Round', serif;
            font-size: 3rem;
            font-weight: bold;
            color: #e74c3c; /* Red for game over */
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.7);
        }

        .final-score {
            font-size: 1.8rem;
            color: #f1c40f;
            margin-top: 1rem;
            font-weight: bold;
        }

        .restart-button {
            background-color: #2ecc71; /* Green button */
            color: #fff;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 6px 8px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: none;
            outline: none;
            -webkit-tap-highlight-color: transparent;
        }

        .restart-button:hover {
            background-color: #27ae60;
            transform: translateY(-2px);
        }

        .restart-button:active {
            background-color: #218c57;
            transform: translateY(0);
            box-shadow: none;
        }
    </style>
    <script type="text/javascript" id="MathJax-script" async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables (will be initialized in initGame)
        window.firebaseApp = null;
        window.db = null;
        window.auth = null;
        window.userId = null;

        // Function to initialize Firebase and authenticate
        window.initFirebase = async () => {
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase config is missing. High score will not be saved.");
                    return;
                }

                window.firebaseApp = initializeApp(firebaseConfig);
                window.db = getFirestore(window.firebaseApp);
                window.auth = getAuth(window.firebaseApp);

                // Sign in anonymously or with custom token
                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(window.auth, __initial_auth_token);
                } else {
                    await signInAnonymously(window.auth);
                }

                onAuthStateChanged(window.auth, (user) => {
                    if (user) {
                        window.userId = user.uid;
                        console.log("Firebase user ID:", window.userId);
                        // Once authenticated, load high score
                        window.loadHighScore();
                    } else {
                        console.log("No user signed in to Firebase.");
                        window.userId = null;
                    }
                });

            } catch (error) {
                console.error("Error initializing Firebase:", error);
            }
        };

        // Function to load high score from Firestore
        window.loadHighScore = async () => {
            if (!window.db || !window.userId) {
                console.log("Firestore or user ID not ready to load high score.");
                return 0;
            }
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const highScoreDocRef = doc(window.db, `artifacts/${appId}/users/${window.userId}/high_scores/personal_high_score`);
                const docSnap = await getDoc(highScoreDocRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    window.highScore = data.score || 0;
                    console.log("Loaded high score:", window.highScore);
                } else {
                    window.highScore = 0;
                    console.log("No high score found for this user, starting at 0.");
                }
                document.getElementById('highScoreDisplay').textContent = window.highScore;
            } catch (error) {
                console.error("Error loading high score:", error);
                window.highScore = 0; // Fallback
            }
        };

        // Function to save high score to Firestore
        window.saveHighScore = async (newScore) => {
            if (!window.db || !window.userId || newScore <= window.highScore) {
                console.log("Not saving high score. Either Firestore/user ID not ready or new score is not higher.");
                return;
            }
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const highScoreDocRef = doc(window.db, `artifacts/${appId}/users/${window.userId}/high_scores/personal_high_score`);
                await setDoc(highScoreDocRef, { score: newScore, timestamp: new Date() });
                window.highScore = newScore; // Update global high score
                document.getElementById('highScoreDisplay').textContent = window.highScore;
                console.log("High score saved successfully:", newScore);
            } catch (error) {
                console.error("Error saving high score:", error);
            }
        };
    </script>
</head>
<body>
    <h1>¬°Que Coman Pasteles!</h1>
    <div class="game-wrapper">
        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            <div class="controls">
                <button id="leftBtn" class="control-button move">Izquierda</button>
                <button id="shootBtn" class="control-button">¬°Disparar!</button>
                <button id="rightBtn" class="control-button move">Derecha</button>
            </div>
        </div>
        <div class="game-info">
            <div class="info-panel">
                <div class="score-display">
                    Puntuaci√≥n: <span id="score">0</span>
                    <img src="https://placehold.co/24x24/fbd38d/34495e?text=üç∞" alt="Pastelito" class="score-icon">
                </div>
            </div>
            <div class="info-panel">
                R√©cord: <span id="highScoreDisplay">0</span>
            </div>
            <div class="info-panel">
                Nivel: <span id="level">1</span>
            </div>
            <div class="info-panel">
                Oleada: <span id="currentWaveDisplay">1</span>/<span id="totalWavesInLevelDisplay">1</span>
            </div>
            <div class="info-panel">
                Enemigos Restantes: <span id="enemiesRemaining">0</span>
            </div>
            <div id="activePowerUpDisplay" class="info-panel">
                Poder Activo: Ninguno
            </div>
        </div>
    </div>

    <div id="gameOverOverlay" class="game-over-overlay" style="display: none;">
        <div class="game-over-text">¬°La Monarqu√≠a ha Ganado!</div>
        <div class="final-score">Pastelitos Obtenidos: <span id="finalScore">0</span> üç∞</div>
        <button id="restartBtn" class="restart-button">Jugar de Nuevo</button>
    </div>

    <div id="questionModal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h2 id="questionTitle">¬°Pregunta de Medida!</h2>
            <p id="questionText"></p>
            <div id="questionOptions" class="modal-options">
                </div>
            <div id="questionFeedback" class="modal-feedback"></div>
            <button id="modalContinueBtn" class="modal-continue-button" style="display: none;">Continuar Juego</button>
        </div>
    </div>

    <script type="module">
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const highScoreDisplay = document.getElementById('highScoreDisplay'); // New high score display
        const levelDisplay = document.getElementById('level');
        const currentWaveDisplay = document.getElementById('currentWaveDisplay'); // New wave display
        const totalWavesInLevelDisplay = document.getElementById('totalWavesInLevelDisplay'); // New total waves display
        const enemiesRemainingDisplay = document.getElementById('enemiesRemaining');
        const gameOverOverlay = document.getElementById('gameOverOverlay');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const shootBtn = document.getElementById('shootBtn');
        const activePowerUpDisplay = document.getElementById('activePowerUpDisplay');

        const questionModal = document.getElementById('questionModal');
        const questionTitle = document.getElementById('questionTitle');
        const questionText = document.getElementById('questionText');
        const questionOptions = document.getElementById('questionOptions');
        const questionFeedback = document.getElementById('questionFeedback');
        const modalContinueBtn = document.getElementById('modalContinueBtn');

        // Game settings
        const GAME_WIDTH = 600; // Fixed width for game logic
        const GAME_HEIGHT = 400; // Fixed height for game logic (will scale with CSS)
        const GUILLOTINE_WIDTH = 60;
        const GUILLOTINE_HEIGHT = 60;
        const PROJECTILE_WIDTH = 8;
        const PROJECTILE_HEIGHT = 20;
        let ENEMY_BASE_WIDTH = 50; // Base size, can be scaled
        let ENEMY_BASE_HEIGHT = 50; // Base size, can be scaled
        const INITIAL_ENEMY_ROWS = 3;
        const INITIAL_ENEMY_COLS = 5;
        const INITIAL_ENEMY_SPACING_X = 70;
        const INITIAL_ENEMY_SPACING_Y = 60;
        const ENEMY_START_Y = 50; // Fixed initial Y position for enemies

        // Obstacle settings
        const DESTRUCTIBLE_ROCK_HEALTH = 3;
        const DESTRUCTIBLE_ROCK_POINTS = 75;
        const INDESTRUCTIBLE_ROCK_POINTS = 0;

        // Power-up settings
        const POWER_UP_DURATION_TRIPLE = 8000; // 8 seconds
        const POWER_UP_DURATION_RAPID = 8000; // 8 seconds
        const POWER_UP_DURATION_PIERCING = 7000; // 7 seconds
        const POWER_UP_DURATION_FREEZE = 5000; // 5 seconds
        const POWER_UP_DURATION_DRONE = 5000; // 5 seconds

        const POWER_UP_WIDTH = 40;
        const POWER_UP_HEIGHT = 40;

        // Boss settings
        const BOSS_WAVE_INTERVAL = 10; // Boss appears every 10 waves cleared
        const BOSS_HEALTH_MULTIPLIER = 5; // Boss health is 5x a regular enemy (base)
        const BOSS_SIZE_MULTIPLIER = 2.5; // Boss is 2.5x larger than base enemy
        const BOSS_ATTACK_COOLDOWN = 1500; // Boss attacks every 1.5 seconds

        let guillotine;
        let projectiles = [];
        let enemies = [];
        let obstacles = []; // New array for obstacles
        let powerUps = []; // New array for falling power-ups
        let drones = []; // New array for active drones
        let boss = null; // Current boss instance
        let bossProjectiles = []; // Projectiles fired by the boss

        let score = 0;
        let highScore = 0; // Global high score variable
        let level = 1;
        let currentWave = 1; // Current wave within the level
        let totalWavesInLevel = 1; // Total waves for the current level
        let wavesClearedTotal = 0; // Total waves cleared across all levels

        let gameLoopId;
        let isGameOver = false;
        let gamePaused = false;
        let enemiesDefeatedThisLevel = 0;

        let activePowerUp = null;
        let powerUpEndTime = 0;
        let originalShootCooldown = 500;
        let currentProjectileWidth = PROJECTILE_WIDTH;
        let currentProjectileHeight = PROJECTILE_HEIGHT;

        let enemiesAreFrozen = false;
        let freezeEndTime = 0;

        // Level configuration for difficulty scaling (up to 30 levels)
        const MAX_LEVELS = 30;
        const levelConfigs = [];

        for (let i = 1; i <= MAX_LEVELS; i++) {
            levelConfigs.push({
                level: i,
                // Waves increase every 5 levels, max 5 waves
                numWaves: Math.min(5, 1 + Math.floor((i - 1) / 5)),
                // Base enemies per wave, increases with level
                baseEnemiesPerWave: Math.min(25, 5 + Math.floor(i * 0.8)),
                // Base obstacles per wave, increases with level
                baseObstaclesPerWave: Math.min(10, Math.floor(i * 0.3)),
                waveDelay: 2000, // 2 seconds between waves
                // Power-up drop chance increases, but not too high
                // Aumentando la probabilidad de aparici√≥n de poderes
                powerUpDropChance: Math.min(0.5, 0.05 + (i * 0.02)), // Aumentado de 0.01 + (i * 0.012)
                // Rock spawn chance increases
                rockSpawnChance: Math.min(0.5, 0.05 + (i * 0.02)),
                // Indestructible rock chance increases
                indestructibleRockChance: Math.min(0.8, 0.1 + (i * 0.03)),
                // Enemy speed increases
                enemySpeedMultiplier: 0.5 + (i * 0.15),
                // Guillotine cooldown reduction (faster shooting)
                guillotineCooldownReduction: Math.max(50, 500 - (i * 15)), // Min cooldown 50ms
                // Enemy size reduction for higher levels
                enemySizeMultiplier: i > 10 ? Math.max(0.7, 1 - ((i - 10) * 0.02)) : 1 // Reduce size after level 10
            });
        }


        // Game Images (using placeholders for now)
        const guillotineImage = new Image();
        guillotineImage.src = "guillotina.png"; // Guillotine icon

        const marieAntoinetteImage = new Image();
        marieAntoinetteImage.src = "mariaantonietta.png"; // Marie Antoinette

        const louisXVIImage = new Image();
        louisXVIImage.src = "LuisXVI.png"; // Louis XVI

        const crownImage = new Image();
        crownImage.src = "corona.png"; // Crown

        const triangleImage = new Image(); // New image for triangle enemy
        triangleImage.src = "soldado.png"; // Placeholder for triangle enemy

        const destructibleRockImage = new Image();
        destructibleRockImage.src = "pergamino.png"; // Destructible rock placeholder

        const indestructibleRockImage = new Image();
        indestructibleRockImage.src = "bloque.png"; // Indestructible rock placeholder

        // New image for the boss (giant Marie Antoinette)
        const bossMarieAntoinetteImage = new Image();
        bossMarieAntoinetteImage.src = "MAboss.gif"; // A distinct, larger placeholder for the boss

        // Power-up images (placeholders)
        const tripleShotImage = new Image();
        tripleShotImage.src = "tripleshot.png"; // Purple for triple shot

        const rapidFireImage = new Image();
        rapidFireImage.src = "rapidfire.png"; // Green for rapid fire

        const piercingBulletImage = new Image();
        piercingBulletImage.src = "piercingbullet.png"; // Blue for piercing bullet

        const enemyFreezeImage = new Image();
        enemyFreezeImage.src = "congelado.png"; // Light blue for enemy freeze

        const droneCompanionImage = new Image();
        droneCompanionImage.src = "dron.png"; // Yellow for drone companion

        // Power-up types and their properties
        const POWER_UP_TYPES = {
            'triple_shot': {
                image: tripleShotImage,
                effect: 'triple_shot',
                name: 'Disparo Triple',
                duration: POWER_UP_DURATION_TRIPLE
            },
            'rapid_fire': {
                image: rapidFireImage,
                effect: 'rapid_fire',
                name: 'Disparo R√°pido',
                duration: POWER_UP_DURATION_RAPID
            },
            'piercing_bullet': {
                image: piercingBulletImage,
                effect: 'piercing_bullet',
                name: 'Bala Perforante',
                duration: POWER_UP_DURATION_PIERCING
            },
            'enemy_freeze': {
                image: enemyFreezeImage,
                effect: 'enemy_freeze',
                name: 'Congelaci√≥n Enemiga',
                duration: POWER_UP_DURATION_FREEZE
            },
            'drone_companion': {
                image: droneCompanionImage,
                effect: 'drone_companion',
                name: 'Acompa√±ante Dron',
                duration: POWER_UP_DURATION_DRONE
            }
        };


        // Game Entities
        class Guillotine {
            constructor() {
                this.width = GUILLOTINE_WIDTH;
                this.height = GUILLOTINE_HEIGHT;
                this.x = (GAME_WIDTH - this.width) / 2;
                this.y = GAME_HEIGHT - this.height - 10;
                this.speed = 5;
                this.currentShootCooldown = originalShootCooldown; // Initial cooldown in milliseconds
                this.lastShotTime = 0; // Timestamp of the last shot
            }

            draw() {
                ctx.drawImage(guillotineImage, this.x, this.y, this.width, this.height);
            }

            moveLeft() {
                this.x = Math.max(0, this.x - this.speed);
            }

            moveRight() {
                this.x = Math.min(GAME_WIDTH - this.width, this.x + this.speed);
            }

            // createProjectile now takes dx for angle and isPiercing flag
            createProjectile(dx = 0, isPiercing = false, isDroneShot = false) {
                projectiles.push(new Projectile(this.x + this.width / 2 - currentProjectileWidth / 2, this.y, dx, isPiercing, isDroneShot));
            }
        }

        class Projectile {
            constructor(x, y, dx = 0, isPiercing = false, isDroneShot = false) { // dx: -1 for left, 0 for straight, 1 for right
                this.x = x;
                this.y = y;
                this.width = isDroneShot ? PROJECTILE_WIDTH * 0.7 : PROJECTILE_WIDTH; // Smaller for drone
                this.height = isDroneShot ? PROJECTILE_HEIGHT * 0.7 : PROJECTILE_HEIGHT; // Smaller for drone
                this.speed = isDroneShot ? 5 : 7; // Slower for drone
                this.dx = dx * (this.speed / 2); // Horizontal speed component for angled shots
                this.isPiercing = isPiercing;
                this.isDroneShot = isDroneShot;
            }

            draw() {
                if (this.isPiercing) {
                    ctx.fillStyle = '#3498db'; // Blue for piercing
                } else if (this.isDroneShot) {
                    ctx.fillStyle = '#f1c40f'; // Yellow for drone shot
                } else {
                    ctx.fillStyle = '#f39c12'; // Orange/Yellow for normal projectile
                }
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            update() {
                this.y -= this.speed;
                this.x += this.dx; // Move horizontally for angled shots
            }
        }

        class Enemy {
            constructor(x, y, type, currentEnemyWidth, currentEnemyHeight, enemySpeedMultiplier) {
                this.x = x;
                this.y = y;
                this.width = currentEnemyWidth;
                this.height = currentEnemyHeight;
                this.type = type;
                this.image = this.getImageByType(type);
                // Base speed with random variation
                this.speedX = (0.5 + enemySpeedMultiplier) * (0.75 + Math.random() * 0.5); // 75% to 125% of base speed
                this.speedY = 0.1; // Constant downward drift
                this.directionX = Math.random() < 0.5 ? 1 : -1; // Initial horizontal direction
                this.points = this.getPointsByType(type);

                // Timer for random horizontal direction changes
                this.randomDirectionChangeInterval = 1000 + Math.random() * 2000; // Change every 1 to 3 seconds
                this.lastDirectionChangeTime = performance.now();
            }

            getImageByType(type) {
                switch (type) {
                    case 'marie': return marieAntoinetteImage;
                    case 'louis': return louisXVIImage;
                    case 'crown': return crownImage;
                    case 'triangle': return triangleImage; // Use triangle image
                    default: return crownImage; // Fallback
                }
            }

            getPointsByType(type) {
                switch (type) {
                    case 'marie': return 50;
                    case 'louis': return 40;
                    case 'crown': return 20;
                    case 'triangle': return 30; // Points for triangle enemy
                    default: return 10;
                }
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                // Optional: Draw a "frozen" overlay
                if (enemiesAreFrozen) {
                    ctx.fillStyle = 'rgba(173, 216, 230, 0.5)'; // Light blue translucent overlay
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }

            update() {
                if (!enemiesAreFrozen) { // Only move if not frozen
                    const now = performance.now();

                    // Randomly change horizontal direction
                    if (now - this.lastDirectionChangeTime > this.randomDirectionChangeInterval) {
                        this.directionX *= -1; // Flip direction
                        this.randomDirectionChangeInterval = 1000 + Math.random() * 2000; // New random interval
                        this.lastDirectionChangeTime = now;
                    }

                    // Simple side-to-side movement and then drop
                    this.x += this.speedX * this.directionX;
                    this.y += this.speedY; // Constant downward movement

                    // Reverse direction if hitting horizontal boundaries
                    if (this.x + this.width > GAME_WIDTH || this.x < 0) {
                        this.directionX *= -1; // Reverse horizontal direction
                        this.y += this.height / 2; // Drop down when hitting wall (use enemy's height)
                    }

                    // Game over if enemy reaches bottom
                    if (this.y + this.height > GAME_HEIGHT) {
                        endGame();
                    }
                }
            }
        }

        class Obstacle {
            constructor(x, y, type, currentObstacleWidth, currentObstacleHeight, obstacleSpeedMultiplier) {
                this.x = x;
                this.y = y;
                this.width = currentObstacleWidth; // Rocks can be same size as enemies for simplicity
                this.height = currentObstacleHeight;
                this.type = type; // 'destructible_rock' or 'indestructible_rock'
                this.isIndestructible = (type === 'indestructible_rock');
                this.health = this.isIndestructible ? Infinity : DESTRUCTIBLE_ROCK_HEALTH;
                this.initialColor = this.isIndestructible ? '#606060' : '#a0a0a0'; // Darker grey for indestructible, lighter for destructible
                this.color = this.initialColor;
                this.points = this.isIndestructible ? INDESTRUCTIBLE_ROCK_POINTS : DESTRUCTIBLE_ROCK_POINTS;
                this.speed = 0.5 * obstacleSpeedMultiplier; // Rocks move at a slightly slower but increasing speed
                this.direction = 1; // 1 for right, -1 for left
                this.image = this.isIndestructible ? indestructibleRockImage : destructibleRockImage;
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                // Optional: Draw health indicator for destructible rocks
                if (!this.isIndestructible && this.health > 0) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 16px Inter'; // Use Inter font for consistency
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.health, this.x + this.width / 2, this.y + this.height / 2);
                }
            }

            update() {
                // ONLY destructible rocks move
                if (!this.isIndestructible && !enemiesAreFrozen) { // Destructible rocks also freeze
                    this.x += this.speed * this.direction;

                    if (this.x + this.width > GAME_WIDTH || this.x < 0) {
                        this.direction *= -1;
                        this.y += this.height / 2; // Drop down when hitting wall (use obstacle's height)
                    }

                    // Game over if moving obstacle reaches bottom
                    if (this.y + this.height > GAME_HEIGHT) {
                        endGame(); // Moving rocks reaching bottom also cause game over
                    }
                }
                // Indestructible rocks do not move or trigger game over by falling off screen (as they don't fall)
            }

            takeHit() {
                if (!this.isIndestructible) {
                    this.health--;
                    // Visual feedback: briefly change color (or use image for hit state)
                    // Para ahora, solo un destello de color r√°pido
                    this.image.src = "https://placehold.co/50x50/e74c3c/ecf0f1?text=DMG"; // Flash rojo al ser golpeado (cambiado de üí•)
                    setTimeout(() => {
                        this.image.src = destructibleRockImage.src; // Volver a la imagen original
                    }, 100);
                }
            }
        }

        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = POWER_UP_WIDTH;
                this.height = POWER_UP_HEIGHT;
                this.type = type;
                this.image = POWER_UP_TYPES[type].image;
                this.speed = 2; // Power-ups fall slowly
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            }

            update() {
                this.y += this.speed; // Power-ups fall down
            }
        }

        class Drone {
            constructor(guillotine) {
                this.guillotine = guillotine;
                this.width = GUILLOTINE_WIDTH * 0.6; // Smaller than guillotine
                this.height = GUILLOTINE_HEIGHT * 0.6;
                this.x = this.guillotine.x + this.guillotine.width / 2 - this.width / 2; // Follow guillotine
                this.y = this.guillotine.y - this.height - 10; // Slightly above guillotine
                this.speed = 5; // Movement speed to follow guillotine
                this.shootCooldown = 600; // Drone shoots a bit slower than player
                this.lastShotTime = 0;
                this.image = droneCompanionImage; // Use drone image
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
            }

            update() {
                // Follow guillotine's X position
                this.x = this.guillotine.x + this.guillotine.width / 2 - this.width / 2;

                // Make drone shoot
                const now = performance.now();
                if (now - this.lastShotTime > this.shootCooldown) {
                    projectiles.push(new Projectile(this.x + this.width / 2 - PROJECTILE_WIDTH / 2, this.y, 0, false, true)); // Drone shot
                    this.lastShotTime = now;
                }
            }
        }

        class Boss {
            constructor() {
                this.width = ENEMY_BASE_WIDTH * BOSS_SIZE_MULTIPLIER; // Giant Marie Antoinette
                this.height = ENEMY_BASE_HEIGHT * BOSS_SIZE_MULTIPLIER;
                this.x = (GAME_WIDTH - this.width) / 2;
                this.y = 20; // Start near the top
                this.image = bossMarieAntoinetteImage; // Use the distinct boss image
                this.health = 10 * BOSS_HEALTH_MULTIPLIER; // Much higher health
                this.maxHealth = this.health; // For health bar calculation
                this.points = 5000; // High points for defeating boss
                this.speedX = 1; // Initial horizontal speed
                this.speedY = 0.05; // Slow vertical descent
                this.directionX = Math.random() < 0.5 ? 1 : -1;

                this.attackCooldown = BOSS_ATTACK_COOLDOWN; // Boss attacks every 1.5 seconds
                this.lastAttackTime = performance.now();
            }

            draw() {
                ctx.drawImage(this.image, this.x, this.y, this.width, this.height);

                // Draw health bar for the boss
                const healthBarWidth = this.width * (this.health / this.maxHealth);
                ctx.fillStyle = '#e74c3c'; // Red health bar
                ctx.fillRect(this.x, this.y - 15, healthBarWidth, 10);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y - 15, this.width, 10);
            }

            update() {
                if (!enemiesAreFrozen) { // Boss also freezes
                    this.x += this.speedX * this.directionX;
                    this.y += this.speedY;

                    // Bounce off walls
                    if (this.x + this.width > GAME_WIDTH || this.x < 0) {
                        this.directionX *= -1;
                    }

                    // Boss attacks
                    const now = performance.now();
                    if (now - this.lastAttackTime > this.attackCooldown) {
                        this.shootAttack();
                        this.lastAttackTime = now;
                    }

                    // Game over if boss reaches guillotine
                    if (this.y + this.height > guillotine.y) {
                        endGame();
                        return; // Stop game loop immediately
                    }
                }
            }

            shootAttack() {
                // Boss can shoot multiple projectiles or a spread
                // Example: 3 projectiles in a small arc
                bossProjectiles.push(new BossProjectile(this.x + this.width / 2, this.y + this.height, -0.5));
                bossProjectiles.push(new BossProjectile(this.x + this.width / 2, this.y + this.height, 0));
                bossProjectiles.push(new BossProjectile(this.x + this.width / 2, this.y + this.height, 0.5));
            }

            takeHit() {
                this.health--;
            }
        }

        class BossProjectile {
            constructor(x, y, dx = 0) {
                this.x = x;
                this.y = y;
                this.width = PROJECTILE_WIDTH * 1.5; // Slightly larger than player projectiles
                this.height = PROJECTILE_HEIGHT * 1.5;
                this.speed = 4; // Slower than player projectiles, easier to dodge
                this.dx = dx * (this.speed / 2); // Horizontal speed component
            }

            draw() {
                ctx.fillStyle = '#ff0000'; // Red for boss projectiles
                ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height); // Center the projectile
            }

            update() {
                this.y += this.speed; // Moves downwards
                this.x += this.dx;
            }
        }


        // Questions for the game (NEW QUESTIONS)
        const questions = [
            // Parte I: Conjuntos Nulos y ‚ÄúCasi en todos lados‚Äù (Null Sets y a.e.)
            {
                question: "Si $f$ es medible y $f=0$ casi en todos lados, ¬øcu√°l afirmaci√≥n es correcta?",
                options: [
                    { text: "$f$ es identicamente cero.", isCorrect: false, explanation: "Que sea 'casi en todos lados' no implica que sea id√©nticamente cero en todos los puntos." },
                    { text: "$\\mu(\\{x:f(x)\\neq0\\})>0$", isCorrect: false, explanation: "Si $f=0$ casi en todos lados, la medida del conjunto donde $f \\neq 0$ debe ser cero." },
                    { text: "$\\int |f| d\\mu = 0$", isCorrect: true, explanation: "Si $f=0$ casi en todos lados, la integral de su valor absoluto es cero." },
                    { text: "$f \\notin L^1$", isCorrect: false, explanation: "Si la integral de su valor absoluto es cero, entonces $f \\in L^1$." }
                ],
                level: 1
            },
            {
                question: "¬øCu√°l conjunto debe tener medida cero para que dos funciones $f$ y $g$ sean iguales casi en todos lados?",
                options: [
                    { text: "$\\{x:f(x)=g(x)\\}$", isCorrect: false, explanation: "Este es el conjunto donde son iguales, no donde difieren." },
                    { text: "$\\{x:f(x)\\neq g(x)\\}$", isCorrect: true, explanation: "Para que sean iguales casi en todos lados, deben diferir solo en un conjunto de medida cero." },
                    { text: "$\\{x:|f(x)-g(x)|>1\\}$", isCorrect: false, explanation: "Este es un caso espec√≠fico de donde difieren, pero no el conjunto completo." },
                    { text: "$\\{x:f(x) \\text{ no es continua}\\}$", isCorrect: false, explanation: "La continuidad no es directamente relevante para la igualdad casi en todos lados." }
                ],
                level: 1
            },
            {
                question: "Si $f_n \\to f$ punto a punto, pero no casi en todos lados, entonces:",
                options: [
                    { text: "$f_n$ converge uniformemente", isCorrect: false, explanation: "La convergencia punto a punto no implica convergencia uniforme." },
                    { text: "La medida del conjunto donde falla la convergencia puede ser positiva", isCorrect: true, explanation: "Si no converge casi en todos lados, significa que el conjunto donde no converge tiene medida positiva." },
                    { text: "$f$ es continua", isCorrect: false, explanation: "La convergencia punto a punto no implica continuidad de la funci√≥n l√≠mite." },
                    { text: "$f_n \\to f$ en $L^1$", isCorrect: false, explanation: "La convergencia punto a punto no garantiza la convergencia en $L^1$." }
                ],
                level: 1
            },
            {
                question: "¬øCu√°l afirmaci√≥n es equivalente a decir que una propiedad se cumple 'casi en todos lados'?",
                options: [
                    { text: "Se cumple para cada punto de $X$", isCorrect: false, explanation: "Esto ser√≠a 'en todos lados', no 'casi en todos lados'." },
                    { text: "Se cumple en un conjunto abierto", isCorrect: false, explanation: "Un conjunto abierto puede tener medida positiva." },
                    { text: "Se cumple fuera de un conjunto nulo", isCorrect: true, explanation: "Esta es la definici√≥n de 'casi en todos lados'." },
                    { text: "Se cumple sobre un conjunto de medida finita", isCorrect: false, explanation: "Un conjunto de medida finita puede no ser el complemento de un conjunto nulo." }
                ],
                level: 1
            },
            {
                question: "Si $f=g$ a.e. y $f \\in L^1(\\mu)$, entonces:",
                options: [
                    { text: "$g \\notin L^1(\\mu)$", isCorrect: false, explanation: "Si son iguales casi en todos lados y una es integrable, la otra tambi√©n lo es." },
                    { text: "$\\int f d\\mu = \\int g d\\mu$", isCorrect: true, explanation: "Las funciones iguales casi en todos lados tienen la misma integral." },
                    { text: "$f$ y $g$ son continuas", isCorrect: false, explanation: "La igualdad casi en todos lados y la integrabilidad no implican continuidad." },
                    { text: "$\\int |f - g| d\\mu > 0$", isCorrect: false, explanation: "Si $f=g$ a.e., entonces $\\int |f - g| d\\mu = 0$." }
                ],
                level: 1
            },
            // Parte II: Integrales de Funciones Medibles
            {
                question: "Si $f\\geq0$ es medible y $\\int f d\\mu = 0$, entonces:",
                options: [
                    { text: "$f=1$ en un conjunto nulo", isCorrect: false, explanation: "Esto no se deduce de la integral cero." },
                    { text: "$f=0$ a.e.", isCorrect: true, explanation: "Para funciones no negativas, una integral cero implica que la funci√≥n es cero casi en todos lados." },
                    { text: "$\\mu(X)=0$", isCorrect: false, explanation: "La medida del espacio no tiene por qu√© ser cero." },
                    { text: "$f \\notin L^1$", isCorrect: false, explanation: "Si la integral es finita (cero), entonces $f \\in L^1$." }
                ],
                level: 2
            },
            {
                question: "¬øQu√© condici√≥n asegura la integrabilidad de una funci√≥n medible $f$?",
                options: [
                    { text: "$f$ es acotada", isCorrect: false, explanation: "Una funci√≥n acotada no siempre es integrable si el espacio de medida es infinito." },
                    { text: "$\\int |f| d\\mu < \\infty$", isCorrect: true, explanation: "Esta es la definici√≥n de integrabilidad de Lebesgue." },
                    { text: "$\\mu(X) < \\infty$", isCorrect: false, explanation: "Un espacio de medida finita no garantiza la integrabilidad de todas las funciones." },
                    { text: "$f$ es continua", isCorrect: false, explanation: "La continuidad no implica integrabilidad." }
                ],
                level: 2
            },
            {
                question: "Si $f_n \\uparrow f$ y $f_n, f$ son medibles, ¬øqu√© resultado se puede aplicar?",
                options: [
                    { text: "Teorema del Dominio Mon√≥tono (DCT)", isCorrect: false, explanation: "El DCT requiere una funci√≥n dominante integrable." },
                    { text: "Teorema de Fubini", isCorrect: false, explanation: "El Teorema de Fubini es para integrales sobre productos de espacios." },
                    { text: "Teorema de Convergencia Mon√≥tona (MCT)", isCorrect: true, explanation: "El MCT se aplica a sucesiones crecientes de funciones medibles no negativas." },
                    { text: "Teorema de Vitali", isCorrect: false, explanation: "El Teorema de Vitali es para convergencia en $L^1$." }
                ],
                level: 2
            },
            {
                question: "El Teorema de Convergencia Dominada requiere:",
                options: [
                    { text: "Convergencia uniforme", isCorrect: false, explanation: "El DCT requiere convergencia punto a punto, no necesariamente uniforme." },
                    { text: "Una funci√≥n integrable que domine a $f_n$", isCorrect: true, explanation: "Esta es la condici√≥n clave del DCT: $|f_n| \\leq g$ para una $g \\in L^1$." },
                    { text: "$\\mu(X) < \\infty$", isCorrect: false, explanation: "Aunque √∫til, no es una condici√≥n estricta para el DCT en general." },
                    { text: "$f_n \\in L^\\infty$", isCorrect: false, explanation: "Las funciones no necesitan ser acotadas." }
                ],
                level: 2
            },
            {
                question: "Si $f_n \\to f$ en $L^1$, entonces:",
                options: [
                    { text: "$f_n \\to f$ uniformemente", isCorrect: false, explanation: "La convergencia en $L^1$ no implica convergencia uniforme." },
                    { text: "$\\int |f_n - f| d\\mu \\to 0$", isCorrect: true, explanation: "Esta es la definici√≥n de convergencia en $L^1$." },
                    { text: "$f_n = f$ a.e.", isCorrect: false, explanation: "La convergencia no implica que las funciones sean iguales casi en todos lados." },
                    { text: "$f \\notin L^1$", isCorrect: false, explanation: "Si $f_n \\to f$ en $L^1$, entonces $f \\in L^1$." }
                ],
                level: 2
            },
            // Parte III: Espacios Lp y Convergencia
            {
                question: "Una funci√≥n $f \\in L^p$, con $p > 1$, implica que:",
                options: [
                    { text: "$f \\in L^q$ para todo $q < p$ si $\\mu(X) < \\infty$", isCorrect: true, explanation: "En espacios de medida finita, $L^p \\subseteq L^q$ para $p > q$." },
                    { text: "$f \\notin L^1$", isCorrect: false, explanation: "Puede estar en $L^1$." },
                    { text: "$f^2 \\in L^1$", isCorrect: false, explanation: "No necesariamente, a menos que $p \\geq 2$." },
                    { text: "$f$ es continua", isCorrect: false, explanation: "Las funciones en $L^p$ no necesitan ser continuas." }
                ],
                level: 3
            },
            {
                question: "¬øQu√© implica que una sucesi√≥n $f_n \\to f$ en $L^p$?",
                options: [
                    { text: "Convergencia punto a punto", isCorrect: false, explanation: "La convergencia en $L^p$ no implica convergencia punto a punto, solo una subsucesi√≥n puede converger a.e." },
                    { text: "$||f_n - f||_p \\to 0$", isCorrect: true, explanation: "Esta es la definici√≥n de convergencia en $L^p$." },
                    { text: "$f_n \\in L^\\infty$", isCorrect: false, explanation: "Las funciones no necesitan ser acotadas." },
                    { text: "$\\int f_n \\to \\int f$", isCorrect: false, explanation: "Esto es cierto si $p=1$, pero no necesariamente para $p>1$ sin condiciones adicionales." }
                ],
                level: 3
            },
            {
                question: "Si $f \\in L^p \\cap L^q$, con $1 \\leq p < q$, ¬øqu√© afirmaci√≥n es v√°lida?",
                options: [
                    { text: "$f \\notin L^r$ para $r < p$", isCorrect: false, explanation: "Si est√° en $L^p$, tambi√©n est√° en $L^r$ para $r<p$ en espacios de medida finita." },
                    { text: "$||f||_q \\leq ||f||_p$ si $\\mu(X) < \\infty$", isCorrect: true, explanation: "En espacios de medida finita, la norma $L^q$ es menor o igual que la norma $L^p$ para $q>p$." },
                    { text: "$f$ es no medible", isCorrect: false, explanation: "Para estar en $L^p$, la funci√≥n debe ser medible." },
                    { text: "$f \\in L^\\infty$", isCorrect: false, explanation: "No necesariamente, puede ser no acotada." }
                ],
                level: 3
            },
            {
                question: "La completitud de $L^p$ significa que:",
                options: [
                    { text: "Toda sucesi√≥n de Cauchy converge en $L^p$", isCorrect: true, explanation: "Esta es la definici√≥n de un espacio completo (de Banach)." },
                    { text: "$L^p \\subseteq C_c(X)$", isCorrect: false, explanation: "Las funciones en $L^p$ no son necesariamente continuas." },
                    { text: "Todas las funciones son continuas", isCorrect: false, explanation: "La completitud no implica continuidad." },
                    { text: "No hay funciones nulas", isCorrect: false, explanation: "La completitud no se relaciona con la existencia de funciones nulas." }
                ],
                level: 3
            },
            {
                question: "En el espacio $L^\\infty$, la norma es:",
                options: [
                    { text: "$\\int |f| d\\mu$", isCorrect: false, explanation: "Esta es la norma $L^1$." },
                    { text: "Esencial supremo de $|f|$", isCorrect: true, explanation: "La norma $L^\\infty$ es el supremo esencial." },
                    { text: "M√≠nimo de $f$", isCorrect: false, explanation: "No es una norma est√°ndar." },
                    { text: "Promedio de $f$", isCorrect: false, explanation: "No es una norma est√°ndar." }
                ],
                level: 3
            },
            // Parte IV: Evaluaci√≥n e Interpretaci√≥n General
            {
                question: "¬øCu√°l afirmaci√≥n describe mejor el prop√≥sito de la medida de Lebesgue?",
                options: [
                    { text: "Generalizar la noci√≥n de ‚Äútama√±o‚Äù incluso para conjuntos no intuitivos", isCorrect: true, explanation: "La medida de Lebesgue extiende la idea de longitud, √°rea, volumen a conjuntos m√°s complejos." },
                    { text: "Medir solo intervalos abiertos", isCorrect: false, explanation: "Puede medir muchos m√°s tipos de conjuntos." },
                    { text: "Evitar los conjuntos nulos", isCorrect: false, explanation: "Los conjuntos nulos son una parte fundamental de la teor√≠a." },
                    { text: "Asegurar que toda funci√≥n es integrable", isCorrect: false, explanation: "No todas las funciones son integrables de Lebesgue." }
                ],
                level: 4
            },
            {
                question: "¬øPor qu√© es √∫til la $\\sigma$-aditividad?",
                options: [
                    { text: "Permite extender medidas a uniones infinitas", isCorrect: true, explanation: "La $\\sigma$-aditividad es la propiedad clave para manejar uniones contables disjuntas." },
                    { text: "Implica continuidad uniforme", isCorrect: false, explanation: "No tiene relaci√≥n directa con la continuidad uniforme." },
                    { text: "Garantiza acotamiento de funciones", isCorrect: false, explanation: "No garantiza acotamiento." },
                    { text: "Requiere dominio compacto", isCorrect: false, explanation: "No requiere dominio compacto." }
                ],
                level: 4
            },
            {
                question: "Una funci√≥n medible es aquella que:",
                options: [
                    { text: "Es continua en todos los puntos", isCorrect: false, explanation: "Las funciones medibles pueden tener muchas discontinuidades." },
                    { text: "La preimagen de cualquier Borel es medible", isCorrect: true, explanation: "Esta es la definici√≥n de una funci√≥n medible." },
                    { text: "Tiene derivada en todos los puntos", isCorrect: false, explanation: "La diferenciabilidad es una propiedad m√°s fuerte que la medibilidad." },
                    { text: "Se puede escribir como serie de senos", isCorrect: false, explanation: "Esto se refiere a series de Fourier, no a la medibilidad en general." }
                ],
                level: 4
            },
            {
                question: "Si $\\mu(E)=0$, entonces:",
                options: [
                    { text: "Toda funci√≥n sobre $E$ es no medible", isCorrect: false, explanation: "La medibilidad no se ve afectada por la medida del dominio." },
                    { text: "$\\int_E f d\\mu = \\infty$", isCorrect: false, explanation: "La integral sobre un conjunto de medida cero es siempre cero." },
                    { text: "$\\int_E f d\\mu = 0$ para cualquier $f \\in L^1$", isCorrect: true, explanation: "La integral de cualquier funci√≥n integrable sobre un conjunto de medida cero es cero." },
                    { text: "$E$ es denso", isCorrect: false, explanation: "Un conjunto de medida cero no tiene por qu√© ser denso." }
                ],
                level: 4
            },
            {
                question: "El conjunto de funciones simples es:",
                options: [
                    { text: "No medible", isCorrect: false, explanation: "Las funciones simples son por definici√≥n medibles." },
                    { text: "Denso en $L^1$", isCorrect: true, explanation: "Las funciones simples son fundamentales para aproximar funciones en $L^1$." },
                    { text: "Disjunto de $L^1$", isCorrect: false, explanation: "Las funciones simples integrables son elementos de $L^1$." },
                    { text: "No integrable", isCorrect: false, explanation: "Las funciones simples son integrables." }
                ],
                level: 4
            },
            // Parte V: Casos Aplicados y Teoremas
            {
                question: "El teorema de Fubini se aplica cuando:",
                options: [
                    { text: "Se tiene un producto de medidas $\\sigma$-finita", isCorrect: true, explanation: "Fubini es para integrales sobre espacios de producto con medidas $\\sigma$-finitas." },
                    { text: "$f$ es continua", isCorrect: false, explanation: "La continuidad no es una condici√≥n para Fubini." },
                    { text: "La medida es discreta", isCorrect: false, explanation: "Fubini se aplica a medidas generales, no solo discretas." },
                    { text: "Las variables son independientes", isCorrect: false, explanation: "Esto es relevante en probabilidad, no una condici√≥n general para Fubini." }
                ],
                level: 5
            },
            {
                question: "En el contexto del teorema de Radon-Nikod√Ωm, si $\\nu \\ll \\mu$, entonces:",
                options: [
                    { text: "$\\mu \\ll \\nu$", isCorrect: false, explanation: "Esto ser√≠a la equivalencia de medidas, no solo la continuidad absoluta." },
                    { text: "Existe $f \\in L^1(\\mu)$ tal que $d\\nu = f d\\mu$", isCorrect: true, explanation: "Esta es la conclusi√≥n del teorema de Radon-Nikod√Ωm." },
                    { text: "$\\nu = \\mu$", isCorrect: false, explanation: "Las medidas no tienen por qu√© ser iguales." },
                    { text: "$f \\in L^\\infty$", isCorrect: false, explanation: "La densidad no tiene por qu√© ser acotada." }
                ],
                level: 5
            },
            {
                question: "La unicidad de la derivada de Radon‚ÄìNikod√Ωm implica que:",
                options: [
                    { text: "Dos funciones densidad que coincidan a.e. representan la misma medida", isCorrect: true, explanation: "La derivada de Radon-Nikod√Ωm es √∫nica casi en todos lados." },
                    { text: "No puede existir m√°s de una funci√≥n", isCorrect: false, explanation: "Se refiere a la unicidad a.e., no a una √∫nica funci√≥n en sentido estricto." },
                    { text: "La derivada es continua", isCorrect: false, explanation: "La derivada no tiene por qu√© ser continua." },
                    { text: "La medida debe ser finita", isCorrect: false, explanation: "El teorema se aplica a medidas $\\sigma$-finitas." }
                ],
                level: 5
            },
            {
                question: "Si $f_n \\to f$ a.e., pero no en $L^1$, entonces:",
                options: [
                    { text: "$\\int f_n \\to \\int f$", isCorrect: false, explanation: "Si no converge en $L^1$, la integral puede no converger." },
                    { text: "$\\int |f_n - f| d\\mu \\not\\to 0$", isCorrect: true, explanation: "Esto es la negaci√≥n de la convergencia en $L^1$." },
                    { text: "$f_n = f$", isCorrect: false, explanation: "La convergencia a.e. no implica igualdad." },
                    { text: "$f$ no es integrable", isCorrect: false, explanation: "La funci√≥n l√≠mite $f$ puede ser integrable, pero la convergencia en $L^1$ falla por otras razones." }
                ],
                level: 5
            },
            {
                question: "El uso de funciones escalonadas (simple functions) en integraci√≥n es para:",
                options: [
                    { text: "Representar conjuntos nulos", isCorrect: false, explanation: "Se usan para aproximar funciones, no conjuntos nulos." },
                    { text: "Aproximar funciones medibles desde abajo", isCorrect: true, explanation: "Las funciones simples son la base para definir la integral de Lebesgue para funciones no negativas." },
                    { text: "Probar continuidad", isCorrect: false, explanation: "Se usan para la integraci√≥n, no la continuidad." },
                    { text: "Demostrar derivabilidad", isCorrect: false, explanation: "No se usan para la derivabilidad." }
                ],
                level: 5
            },
            // Parte VI: Cr√≠tica de Conceptos
            {
                question: "¬øPor qu√© no toda funci√≥n continua es integrable?",
                options: [
                    { text: "Puede divergir en un conjunto de medida no cero", isCorrect: true, explanation: "Una funci√≥n continua puede no ser integrable si su integral sobre un conjunto de medida positiva es infinita (ej. $f(x)=x$ en $\\mathbb{R}$)." },
                    { text: "Porque la continuidad impide la acotaci√≥n", isCorrect: false, explanation: "La continuidad no impide la acotaci√≥n; una funci√≥n puede ser continua y no acotada." },
                    { text: "Por no ser medible", isCorrect: false, explanation: "Toda funci√≥n continua es medible." },
                    { text: "Porque no son simples", isCorrect: false, explanation: "La integrabilidad no depende de ser una funci√≥n simple." }
                ],
                level: 6 // Asignar a un nivel m√°s alto si se desea que aparezca m√°s tarde
            },
            {
                question: "Si una propiedad se cumple fuera de un conjunto de medida cero, entonces:",
                options: [
                    { text: "Se cumple en un conjunto abierto", isCorrect: false, explanation: "No necesariamente, el complemento de un conjunto de medida cero no tiene por qu√© ser abierto." },
                    { text: "Se dice que se cumple a.e.", isCorrect: true, explanation: "Esta es la definici√≥n de 'casi en todos lados' (a.e.)." },
                    { text: "No se puede integrar", isCorrect: false, explanation: "La integrabilidad no se ve afectada por esto." },
                    { text: "La funci√≥n es no medible", isCorrect: false, explanation: "La medibilidad no se ve afectada por esto." }
                ],
                level: 6
            },
            {
                question: "¬øQu√© sucede si $f \\notin L^1$ pero $\\mu(\\{x:|f(x)|>1\\})=0$?",
                options: [
                    { text: "$f$ es integrable", isCorrect: false, explanation: "Si $f \\notin L^1$, no es integrable." },
                    { text: "$f$ no es medible", isCorrect: false, explanation: "La condici√≥n de medida cero no implica no medibilidad." },
                    { text: "$f$ puede divergir sobre un conjunto de medida cero", isCorrect: true, explanation: "La funci√≥n puede ser muy grande en un conjunto de medida cero, lo que la hace no integrable, incluso si es 'casi' acotada." },
                    { text: "$f=0$ a.e.", isCorrect: false, explanation: "La condici√≥n de medida cero para $|f|>1$ no implica que $f=0$ a.e." }
                ],
                level: 6
            },
            {
                question: "La integral de Lebesgue permite:",
                options: [
                    { text: "Integrar funciones con infinitos discontinuidades", isCorrect: true, explanation: "La integral de Lebesgue es m√°s general que la de Riemann y puede integrar funciones con muchas discontinuidades." },
                    { text: "Solo funciones acotadas", isCorrect: false, explanation: "Puede integrar funciones no acotadas." },
                    { text: "√önicamente funciones continuas", isCorrect: false, explanation: "Integra funciones medibles, que no tienen por qu√© ser continuas." },
                    { text: "Riemannianas equivalentes", isCorrect: false, explanation: "Es una generalizaci√≥n, no solo una equivalencia." }
                ],
                level: 6
            },
            {
                question: "¬øQu√© teorema es m√°s adecuado para comparar $\\int f_n \\to \\int f$?",
                options: [
                    { text: "Mon√≥tono", isCorrect: false, explanation: "El Teorema de Convergencia Mon√≥tona (MCT) es para sucesiones crecientes." },
                    { text: "Dominado", isCorrect: true, explanation: "El Teorema de Convergencia Dominada (DCT) es el m√°s general para intercambiar l√≠mite e integral." },
                    { text: "Inverso", isCorrect: false, explanation: "No es un teorema est√°ndar de convergencia de integrales." },
                    { text: "Tychonoff", isCorrect: false, explanation: "El teorema de Tychonoff es sobre topolog√≠a, no convergencia de integrales." }
                ],
                level: 6
            }
        ];

        let currentQuestion = null;
        let answeredQuestions = new Set(); // To keep track of questions already asked

        // Utility function to shuffle an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
            return array;
        }

        // Game Functions
        async function initGame() {
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;

            guillotine = new Guillotine();
            projectiles = [];
            enemies = [];
            obstacles = []; // Initialize obstacles array
            powerUps = []; // Initialize power-ups array
            drones = []; // Initialize drones array
            boss = null; // Reset boss
            bossProjectiles = []; // Reset boss projectiles
            score = 0;
            level = 1;
            currentWave = 1;
            wavesClearedTotal = 0; // Reset total waves cleared
            isGameOver = false;
            gamePaused = false;
            enemiesDefeatedThisLevel = 0;
            answeredQuestions.clear();

            // Store original values for power-up reset
            originalShootCooldown = 500;
            currentProjectileWidth = PROJECTILE_WIDTH;
            currentProjectileHeight = PROJECTILE_HEIGHT;
            guillotine.currentShootCooldown = originalShootCooldown; // Ensure initial cooldown is set

            activePowerUp = null; // No active power-up at start
            powerUpEndTime = 0;
            enemiesAreFrozen = false; // Ensure enemies are not frozen at start
            freezeEndTime = 0; // Reset freeze end time
            activePowerUpDisplay.textContent = 'Poder Activo: Ninguno'; // Reset power-up display

            scoreDisplay.textContent = score;
            levelDisplay.textContent = level;
            currentWaveDisplay.textContent = currentWave;
            // Set total waves for level 1 initially
            totalWavesInLevel = levelConfigs[0].numWaves;
            totalWavesInLevelDisplay.textContent = totalWavesInLevel;
            enemiesRemainingDisplay.textContent = 0; // Reset for initial display
            gameOverOverlay.style.display = 'none';
            questionModal.style.display = 'none';

            // Initialize Firebase and load high score
            await window.initFirebase();
            await window.loadHighScore(); // This will update highScoreDisplay

            spawnWave(); // Call spawnWave instead of spawnEntities for the first wave
            triggerQuestion(); // Trigger first question for Level 1
            startGameLoop();
        }

        function spawnWave() {
            enemies = [];
            obstacles = []; // Clear obstacles for new wave
            powerUps = []; // Clear power-ups for new wave
            drones = []; // Clear drones for new wave (drones are tied to power-up duration, but clear on new wave for simplicity)

            const currentLevelConfig = levelConfigs[level - 1]; // Get config for current level
            if (!currentLevelConfig) {
                console.error(`No level config found for level ${level}. Ending game.`);
                endGame();
                return;
            }

            const enemyTypes = ['crown', 'crown', 'louis', 'marie', 'triangle'];

            // Adjust enemy/obstacle size based on level config
            const currentEnemyWidth = ENEMY_BASE_WIDTH * currentLevelConfig.enemySizeMultiplier;
            const currentEnemyHeight = ENEMY_BASE_HEIGHT * currentLevelConfig.enemySizeMultiplier;

            // Calculate grid dimensions based on number of entities for this wave
            const numEntitiesForWave = currentLevelConfig.baseEnemiesPerWave + currentLevelConfig.baseObstaclesPerWave;
            // A simple way to arrange them: calculate rows/cols to fit N entities
            const estimatedCols = Math.min(10, Math.ceil(Math.sqrt(numEntitiesForWave * 1.5))); // Try to make it somewhat square-ish
            const estimatedRows = Math.ceil(numEntitiesForWave / estimatedCols);

            const dynamicEntitySpacingX = Math.max(currentEnemyWidth + 10, INITIAL_ENEMY_SPACING_X - (level - 1) * 3);
            const dynamicEntitySpacingY = Math.max(currentEnemyHeight + 10, INITIAL_ENEMY_SPACING_Y - (level - 1) * 3);

            const totalGridWidth = estimatedCols * dynamicEntitySpacingX - (dynamicEntitySpacingX - currentEnemyWidth);
            const dynamicStartX = (GAME_WIDTH - totalGridWidth) / 2;
            const dynamicStartY = ENEMY_START_Y;

            // Power-up drop chance for this level
            const powerUpDropChance = currentLevelConfig.powerUpDropChance;
            const rockSpawnChance = currentLevelConfig.rockSpawnChance;
            const indestructibleRockChance = currentLevelConfig.indestructibleRockChance;

            let entitiesSpawnedInWave = 0;
            const maxEntitiesToSpawn = currentLevelConfig.baseEnemiesPerWave + currentLevelConfig.baseObstaclesPerWave;

            // Spawn entities for the current wave
            for (let r = 0; r < estimatedRows && entitiesSpawnedInWave < maxEntitiesToSpawn; r++) {
                for (let c = 0; c < estimatedCols && entitiesSpawnedInWave < maxEntitiesToSpawn; c++) {
                    const entityX = dynamicStartX + c * dynamicEntitySpacingX + (Math.random() - 0.5) * 10;
                    const entityY = dynamicStartY + r * dynamicEntitySpacingY;

                    if (Math.random() < rockSpawnChance) {
                        const rockType = Math.random() < indestructibleRockChance ? 'indestructible_rock' : 'destructible_rock';
                        obstacles.push(new Obstacle(entityX, entityY, rockType, currentEnemyWidth, currentEnemyHeight, currentLevelConfig.enemySpeedMultiplier));
                    } else {
                        const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                        enemies.push(new Enemy(entityX, entityY, type, currentEnemyWidth, currentEnemyHeight, currentLevelConfig.enemySpeedMultiplier));
                    }
                    entitiesSpawnedInWave++;
                }
            }

            // Ensure at least one entity is spawned if nothing was generated
            if (entitiesSpawnedInWave === 0 && maxEntitiesToSpawn > 0) {
                const type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                enemies.push(new Enemy(GAME_WIDTH / 2 - currentEnemyWidth / 2, ENEMY_START_Y, type, currentEnemyWidth, currentEnemyHeight, currentLevelConfig.enemySpeedMultiplier));
            }

            enemiesRemainingDisplay.textContent = enemies.length + obstacles.filter(o => !o.isIndestructible).length;
        }

        function spawnBoss() {
            boss = new Boss();
            enemies = []; // Clear any regular enemies
            obstacles = []; // Clear any obstacles
            powerUps = []; // Clear any power-ups
            drones = []; // Clear any drones
            bossProjectiles = []; // Clear any existing boss projectiles

            // Update display to reflect boss fight
            enemiesRemainingDisplay.textContent = "¬°JEFE!";
            activePowerUpDisplay.textContent = "¬°Cuidado!";
            gamePaused = false; // Ensure game is unpaused for boss fight
            startGameLoop();
        }


        function startGameLoop() {
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
            }
            gameLoop();
        }

        // Function to check if the current wave is completed and handle transitions
        function checkWaveCompletion() {
            // Check if all regular enemies and destructible obstacles are defeated
            const remainingDestructibleEntities = enemies.length + obstacles.filter(o => !o.isIndestructible).length;

            if (boss) {
                // If there's a boss, wave completion is tied to boss defeat
                return; // Do nothing, boss logic handles progression
            }

            if (remainingDestructibleEntities === 0) {
                wavesClearedTotal++; // Increment total waves cleared

                const currentLevelConfig = levelConfigs[level - 1];

                if (wavesClearedTotal % BOSS_WAVE_INTERVAL === 0) {
                    // Time for a boss fight!
                    gamePaused = true; // Pause briefly before boss appears
                    setTimeout(() => {
                        spawnBoss();
                        gamePaused = false; // Unpause for boss fight
                        startGameLoop();
                    }, 2000); // Small delay before boss spawns
                } else if (currentWave < currentLevelConfig.numWaves) {
                    // Advance to next regular wave
                    currentWave++;
                    currentWaveDisplay.textContent = currentWave;
                    gamePaused = true; // Pause game during wave transition
                    setTimeout(() => {
                        spawnWave();
                        gamePaused = false; // Unpause after wave spawns
                        startGameLoop();
                    }, currentLevelConfig.waveDelay); // Small delay before next wave
                } else {
                    // All waves completed for the current level, level up!
                    levelUp();
                }
            }
        }

        function gameLoop() {
            if (isGameOver) {
                return;
            }
            if (gamePaused) {
                gameLoopId = requestAnimationFrame(gameLoop); // Keep requesting frames to unpause
                return;
            }

            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT); // Clear canvas

            guillotine.draw();

            // Store indices of entities to be removed
            let enemiesToRemove = new Set();
            let projectilesToRemove = new Set();
            let obstaclesToRemove = new Set();
            let powerUpsToRemove = new Set(); // New set for power-ups to remove

            // Update and draw boss (if active)
            if (boss) {
                boss.update();
                boss.draw();

                // Process player projectiles
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    p.update(); // ALWAYS update projectile position
                    p.draw();   // ALWAYS draw projectile

                    // Check if projectile is off-screen
                    if (p.y + p.height < 0 || p.x < -PROJECTILE_WIDTH || p.x > GAME_WIDTH) {
                        projectiles.splice(i, 1);
                        continue; // Move to the next projectile
                    }

                    // Check collision with boss
                    if (checkCollision(p, boss)) {
                        boss.takeHit();
                        if (!p.isPiercing) {
                            projectiles.splice(i, 1); // Remove non-piercing projectile
                        }
                        if (boss.health <= 0) {
                            score += boss.points;
                            scoreDisplay.textContent = score;
                            boss = null; // Boss defeated!
                            // Clear remaining boss projectiles
                            bossProjectiles = [];
                            gamePaused = true; // Pause for transition
                            setTimeout(() => {
                                levelUp(); // Proceed to next level
                                gamePaused = false;
                                startGameLoop();
                            }, 2000); // Small delay before next level
                            break; // Exit player projectile loop as boss is defeated
                        }
                    }
                }

                // Update and draw boss projectiles
                for (let i = bossProjectiles.length - 1; i >= 0; i--) {
                    const bp = bossProjectiles[i];
                    bp.update();
                    bp.draw();

                    // Check collision with guillotine
                    if (checkCollision(guillotine, bp)) {
                        endGame(); // Game over if boss projectile hits guillotine
                        return; // Stop game loop immediately
                    }

                    // Remove if off-screen
                    if (bp.y > GAME_HEIGHT) {
                        bossProjectiles.splice(i, 1);
                    }
                }
            } else { // Only process regular enemies/obstacles if no boss is active
                // Update projectiles and check for collisions (against regular enemies/obstacles)
                for (let i = 0; i < projectiles.length; i++) {
                    const projectile = projectiles[i];
                    projectile.update();

                    // Mark projectile for removal if it goes off screen
                    if (projectile.y + projectile.height < 0 || projectile.x < -PROJECTILE_WIDTH || projectile.x > GAME_WIDTH) {
                        projectilesToRemove.add(i);
                        continue;
                    }

                    let hitThisProjectile = false; // Flag to track if this projectile hit anything (for non-piercing)

                    // Check for collisions with enemies
                    for (let j = 0; j < enemies.length; j++) {
                        const enemy = enemies[j];
                        if (checkCollision(projectile, enemy)) {
                            score += enemy.points;
                            scoreDisplay.textContent = score;
                            enemiesDefeatedThisLevel++;
                            enemiesToRemove.add(j);

                            // Chance to drop a power-up when an enemy is destroyed
                            const currentLevelConfig = levelConfigs[level - 1];
                            const powerUpDropChance = currentLevelConfig ? currentLevelConfig.powerUpDropChance : 0.01; // Default low chance
                            if (Math.random() < powerUpDropChance) {
                                const powerUpTypesArray = Object.keys(POWER_UP_TYPES);
                                const randomPowerUpType = powerUpTypesArray[Math.floor(Math.random() * powerUpTypesArray.length)];
                                powerUps.push(new PowerUp(enemy.x + enemy.width / 2 - POWER_UP_WIDTH / 2, enemy.y + enemy.height / 2 - POWER_UP_HEIGHT / 2, randomPowerUpType));
                            }

                            if (!projectile.isPiercing) { // Only destroy projectile if not piercing
                                projectilesToRemove.add(i);
                                hitThisProjectile = true;
                                break; // Stop checking enemies for this projectile if it's not piercing
                            }
                        }
                    }
                    if (hitThisProjectile) continue; // If non-piercing hit an enemy, move to next projectile

                    // Check for collisions with obstacles
                    for (let k = 0; k < obstacles.length; k++) {
                        const obstacle = obstacles[k];
                        if (checkCollision(projectile, obstacle)) {
                            if (obstacle.isIndestructible) {
                                projectilesToRemove.add(i); // Projectile always destroyed by hitting an indestructible obstacle
                                hitThisProjectile = true;
                            } else { // Destructible rock
                                obstacle.takeHit();
                                if (obstacle.health <= 0) {
                                    obstaclesToRemove.add(k);
                                    score += obstacle.points; // Add points for destroying obstacles
                                }
                                if (!projectile.isPiercing) { // Only destroy projectile if not piercing
                                    projectilesToRemove.add(i);
                                    hitThisProjectile = true;
                                }
                            }
                            if (hitThisProjectile) break; // Stop checking obstacles for this projectile if it's not piercing or hit indestructible
                        }
                    }
                }

                // Filter out removed entities
                projectiles = projectiles.filter((_, index) => !projectilesToRemove.has(index));
                enemies = enemies.filter((_, index) => !enemiesToRemove.has(index));
                obstacles = obstacles.filter((_, index) => !obstaclesToRemove.has(index));

                // Update and draw remaining projectiles
                for (const projectile of projectiles) {
                    projectile.draw();
                }

                // Update and draw enemies
                for (const enemy of enemies) {
                    enemy.update();
                    enemy.draw();
                }

                // Update and draw obstacles
                for (const obstacle of obstacles) {
                    obstacle.update(); // Only destructible ones move (and freeze if active)
                    obstacle.draw();
                }

                // Update and draw power-ups, check for collection
                for (let i = 0; i < powerUps.length; i++) {
                    const powerUp = powerUps[i];
                    powerUp.update();
                    powerUp.draw();

                    // Check collision with guillotine
                    if (checkCollision(guillotine, powerUp)) {
                        applyPowerUp(powerUp.type);
                        powerUpsToRemove.add(i);
                    }

                    // Remove if off screen
                    if (powerUp.y > GAME_HEIGHT) {
                        powerUpsToRemove.add(i);
                    }
                }
                powerUps = powerUps.filter((_, index) => !powerUpsToRemove.has(index));

                // Update and draw drones
                for (const drone of drones) {
                    drone.update();
                    drone.draw();
                }
            }


            // Check for power-up expiration
            const now = performance.now();
            if (activePowerUp && now > powerUpEndTime) {
                removePowerUp();
            }
            // Check for freeze power-up expiration separately
            if (enemiesAreFrozen && now > freezeEndTime) {
                enemiesAreFrozen = false;
            }


            // Update enemies remaining display (only enemies and destructible obstacles)
            // If boss is active, display "JEFE!"
            if (!boss) {
                enemiesRemainingDisplay.textContent = enemies.length + obstacles.filter(o => !o.isIndestructible).length;
            }


            checkWaveCompletion();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function levelUp() {
            // Check if max levels reached
            if (level >= MAX_LEVELS) {
                console.log("¬°Felicidades! Has completado todos los niveles.");
                endGame(true); // Game won scenario
                return;
            }

            level++;
            levelDisplay.textContent = level;
            enemiesDefeatedThisLevel = 0; // Reset count for new level
            currentWave = 1; // Reset wave for new level
            currentWaveDisplay.textContent = currentWave;

            const currentLevelConfig = levelConfigs[level - 1];
            totalWavesInLevel = currentLevelConfig.numWaves;
            totalWavesInLevelDisplay.textContent = totalWavesInLevel;

            spawnWave(); // Spawn first wave of new level
            triggerQuestion(); // Trigger a question for the new level

            // Decrease guillotine cooldown for faster shooting (base speed)
            originalShootCooldown = currentLevelConfig.guillotineCooldownReduction;
            guillotine.currentShootCooldown = originalShootCooldown; // Reset to new base cooldown
            removePowerUp(); // Ensure any active power-up is removed when leveling up
        }

        function endGame(wonGame = false) {
            isGameOver = true;
            cancelAnimationFrame(gameLoopId);
            finalScoreDisplay.textContent = score;
            gameOverOverlay.style.display = 'flex';

            if (wonGame) {
                document.querySelector('.game-over-text').textContent = '¬°Has Restaurado la Rep√∫blica!';
                document.querySelector('.game-over-text').style.color = '#2ecc71'; // Green for win
            } else {
                document.querySelector('.game-over-text').textContent = '¬°La Monarqu√≠a ha Ganado!';
                document.querySelector('.game-over-text').style.color = '#e74c3c'; // Red for lose
            }

            // Save high score if current score is higher
            if (score > window.highScore) {
                window.saveHighScore(score);
            }
        }

        function availableQuestionsForLevel() {
            return questions.filter(q => q.level <= level && !answeredQuestions.has(q));
        }

        function triggerQuestion() {
            gamePaused = true;
            let availableQs = availableQuestionsForLevel();

            if (availableQs.length > 0) {
                // Pick a random question from available ones
                currentQuestion = availableQs[Math.floor(Math.random() * availableQs.length)];
                answeredQuestions.add(currentQuestion); // Mark as asked

                questionTitle.textContent = "¬°Pregunta de Medida!"; // Changed title
                questionText.textContent = currentQuestion.question;
                questionOptions.innerHTML = ''; // Clear previous options
                questionFeedback.textContent = '';
                modalContinueBtn.style.display = 'none';

                // Shuffle the options before displaying them
                const shuffledOptions = shuffleArray([...currentQuestion.options]); // Create a shallow copy to shuffle

                shuffledOptions.forEach((option, index) => {
                    const button = document.createElement('button');
                    // Create a span to hold the MathJax content
                    const span = document.createElement('span');
                    span.textContent = option.text; // Set the LaTeX string here
                    button.appendChild(span); // Append the span to the button

                    button.onclick = () => selectAnswer(option, button);
                    questionOptions.appendChild(button);
                });

                questionModal.style.display = 'flex';
                // Render MathJax after content is added to the DOM
                if (window.MathJax) {
                    // Tell MathJax to typeset the question text and the newly created buttons within questionOptions
                    // MathJax will process the spans inside the buttons.
                    window.MathJax.typesetPromise([questionText, questionOptions]).then(() => {
                        console.log('MathJax typeset complete');
                    }).catch((err) => console.error('MathJax typesetting failed:', err));
                }
            } else {
                // No more questions for this level or already answered all
                gamePaused = false; // Resume game if no question
                startGameLoop();
            }
        }

        function selectAnswer(selectedOption, clickedButton) {
            // Disable all options after selection
            Array.from(questionOptions.children).forEach(button => {
                button.disabled = true;
                // Find the original option object associated with this button's text
                const originalOptionText = button.querySelector('span').textContent; // Get text from the span
                const originalOption = currentQuestion.options.find(opt => opt.text === originalOptionText);

                if (button === clickedButton) {
                    button.classList.add(selectedOption.isCorrect ? 'correct' : 'incorrect');
                } else if (originalOption && originalOption.isCorrect) {
                    button.classList.add('correct'); // Highlight correct answer
                }
            });

            if (selectedOption.isCorrect) {
                questionFeedback.textContent = "¬°Correcto! ¬°Viva la Revoluci√≥n!";
                questionFeedback.classList.remove('incorrect');
                questionFeedback.classList.add('correct');
                score += 100; // Bonus points for correct answer
                scoreDisplay.textContent = score;
            } else {
                questionFeedback.textContent = `Incorrecto. ${selectedOption.explanation}`;
                questionFeedback.classList.remove('correct');
                questionFeedback.classList.add('incorrect');
            }
            modalContinueBtn.style.display = 'block';
        }

        modalContinueBtn.addEventListener('click', () => {
            questionModal.style.display = 'none';
            gamePaused = false;
            startGameLoop();
        });

        // Function to handle shooting (with cooldown and power-ups)
        function handleShoot() {
            const now = performance.now();
            let effectiveCooldown = guillotine.currentShootCooldown; // Start with base cooldown

            if (activePowerUp === 'rapid_fire') {
                effectiveCooldown = Math.max(50, originalShootCooldown / 3); // Much faster shooting
            } else if (activePowerUp === 'piercing_bullet') {
                effectiveCooldown = originalShootCooldown * 1.2; // Slightly slower for piercing
            }

            if (!isGameOver && !gamePaused && (now - guillotine.lastShotTime > effectiveCooldown)) {
                if (activePowerUp === 'triple_shot') {
                    // Triple shot: vertical, 45 deg left, 45 deg right
                    guillotine.createProjectile(0, false); // Vertical (not piercing by default)
                    guillotine.createProjectile(-0.7, false); // Angled left
                    guillotine.createProjectile(0.7, false); // Angled right
                } else if (activePowerUp === 'piercing_bullet') {
                    guillotine.createProjectile(0, true); // Piercing bullet
                } else {
                    guillotine.createProjectile(0, false); // Normal shot
                }
                guillotine.lastShotTime = now;
            }
        }

        function applyPowerUp(type) {
            // If a power-up is already active, remove it first
            if (activePowerUp) {
                removePowerUp();
            }

            activePowerUp = type;
            powerUpEndTime = performance.now() + POWER_UP_TYPES[type].duration;
            activePowerUpDisplay.textContent = `Poder Activo: ${POWER_UP_TYPES[type].name}`;

            // Apply specific effects
            if (type === 'rapid_fire') {
                // Cooldown is handled in handleShoot, no direct change here
            } else if (type === 'piercing_bullet') {
                // Piercing effect is handled in gameLoop collision logic
            } else if (type === 'enemy_freeze') {
                enemiesAreFrozen = true;
                freezeEndTime = performance.now() + POWER_UP_TYPES[type].duration;
            } else if (type === 'drone_companion') {
                drones.push(new Drone(guillotine));
            }
        }

        function removePowerUp() {
            if (!activePowerUp) return; // No power-up to remove

            // Revert effects
            if (activePowerUp === 'rapid_fire') {
                // Cooldown reverts automatically in handleShoot
            } else if (activePowerUp === 'piercing_bullet') {
                // No specific projectile size change, effect handled in collision
            } else if (activePowerUp === 'enemy_freeze') {
                enemiesAreFrozen = false; // Ensure enemies unfreeze
            } else if (activePowerUp === 'drone_companion') {
                drones = []; // Remove all drones
            }
            activePowerUp = null;
            powerUpEndTime = 0;
            activePowerUpDisplay.textContent = 'Poder Activo: Ninguno'; // Update power-up display
        }


        // Event Listeners for controls (Mouse/Touch for continuous movement)
        let moveLeftInterval = null;
        let moveRightInterval = null;

        leftBtn.addEventListener('mousedown', () => {
            if (!isGameOver && !gamePaused && !moveLeftInterval) { // Prevent multiple intervals
                moveLeftInterval = setInterval(() => guillotine.moveLeft(), 20);
            }
        });
        leftBtn.addEventListener('mouseup', () => { clearInterval(moveLeftInterval); moveLeftInterval = null; });
        leftBtn.addEventListener('mouseleave', () => { clearInterval(moveLeftInterval); moveLeftInterval = null; });
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!isGameOver && !gamePaused && !moveLeftInterval) {
                moveLeftInterval = setInterval(() => guillotine.moveLeft(), 20);
            }
        }, { passive: false });
        leftBtn.addEventListener('touchend', () => { clearInterval(moveLeftInterval); moveLeftInterval = null; });
        leftBtn.addEventListener('touchcancel', () => { clearInterval(moveLeftInterval); moveLeftInterval = null; });

        rightBtn.addEventListener('mousedown', () => {
            if (!isGameOver && !gamePaused && !moveRightInterval) { // Prevent multiple intervals
                moveRightInterval = setInterval(() => guillotine.moveRight(), 20);
            }
        });
        rightBtn.addEventListener('mouseup', () => { clearInterval(moveRightInterval); moveRightInterval = null; });
        rightBtn.addEventListener('mouseleave', () => { clearInterval(moveRightInterval); moveRightInterval = null; });
        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!isGameOver && !gamePaused && !moveRightInterval) {
                moveRightInterval = setInterval(() => guillotine.moveRight(), 20);
            }
        }, { passive: false });
        rightBtn.addEventListener('touchend', () => { clearInterval(moveRightInterval); moveRightInterval = null; });
        rightBtn.addEventListener('touchcancel', () => { clearInterval(moveRightInterval); moveRightInterval = null; });


        shootBtn.addEventListener('click', handleShoot); // Use the new handleShoot function

        // Keyboard controls for continuous movement
        let keyboardMoveLeftInterval = null;
        let keyboardMoveRightInterval = null;
        let keysPressed = {}; // To track currently pressed keys

        document.addEventListener('keydown', (e) => {
            if (isGameOver || gamePaused) return;

            // Prevent repeat calls if key is held down
            if (keysPressed[e.key]) return;
            keysPressed[e.key] = true;

            switch (e.key) {
                case 'ArrowLeft':
                    if (!keyboardMoveLeftInterval) {
                        keyboardMoveLeftInterval = setInterval(() => guillotine.moveLeft(), 20);
                    }
                    break;
                case 'ArrowRight':
                    if (!keyboardMoveRightInterval) {
                        keyboardMoveRightInterval = setInterval(() => guillotine.moveRight(), 20);
                    }
                    break;
                case ' ': // Spacebar to shoot
                    e.preventDefault(); // Prevent scrolling down
                    handleShoot(); // Use the new handleShoot function
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false; // Mark key as released

            switch (e.key) {
                case 'ArrowLeft':
                    clearInterval(keyboardMoveLeftInterval);
                    keyboardMoveLeftInterval = null;
                    break;
                case 'ArrowRight':
                    clearInterval(keyboardMoveRightInterval);
                    keyboardMoveRightInterval = null;
                    break;
            }
        });

        restartBtn.addEventListener('click', initGame);

        // Initialize game on window load
        window.onload = initGame;
    </script>
</body>
</html>
